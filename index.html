<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Poker ‚Äî Tournament (UI+FX)</title>
<style>
  :root{
    --bg:#07110f;
    --felt1:#0f6a45;
    --felt2:#06402c;
    --feltLine:#ffffff14;

    --glass:#071215cc;
    --line:#ffffff18;

    --text:#eaf5f1;
    --muted:#b5c9c1;

    --accent:#63f2c5;
    --warn:#ffd27a;
    --danger:#ff6b6b;

    --btn:#0b1417;
    --btn2:#0a1d1a;

    --card:#f7f8fc;
    --cardText:#0b0f12;

    --shadow:#00000070;

    --neon:#63f2c5;
    --neon2:#b8ffe9;

    --turnSec: 15;
  }

  /* Night theme overrides */
  body.night{
    --felt1:#4a4f55;
    --felt2:#2c3036;
    --bg:#0a0c10;
    --card:#0b0f12;
    --cardText:#eaf5f1;
    --neon:#8aa3ff;
    --neon2:#d7e0ff;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    color:var(--text);
    background: radial-gradient(1200px 720px at 50% 28%, #0f3a2e, var(--bg));
    overflow:hidden;
  }

  /* TABLE */
  .table{
    position:fixed; inset:0;
    background: radial-gradient(130% 110% at 50% 42%, var(--felt1), var(--felt2));
    overflow:hidden;
  }
  .table::before{
    content:"";
    position:absolute;
    inset:min(3.6vh, 26px);
    border-radius:999px;
    border:2px solid var(--feltLine);
    pointer-events:none;
  }
  .table::after{
    content:"";
    position:absolute; inset:0;
    background: radial-gradient(900px 520px at 50% 50%, transparent, #00000045);
    pointer-events:none;
  }

  /* TOP HUD */
  .hud{
    position:absolute;
    top:14px; left:50%;
    transform:translateX(-50%);
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:center;
    padding:8px;
    z-index:20;
  }
  .pill{
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding:7px 12px;
    border-radius:999px;
    background: #00000030;
    border:1px solid var(--line);
    color:var(--muted);
    font-size:14px;
    backdrop-filter: blur(8px);
  }
  .pill b{ color:var(--text); }

  .msg{
    position:absolute;
    left:50%;
    top:92px;
    transform:translateX(-50%);
    width:min(860px, 92vw);
    text-align:center;
    font-size:14px;
    color:var(--text);
    opacity:.95;
    z-index:20;
    min-height:18px;
    text-shadow: 0 6px 18px #00000066;
  }

  /* CENTER BOARD */
  .center{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:min(860px, 92vw);
    z-index:10;
    text-align:center;
  }
  .board{
    display:flex;
    justify-content:center;
    gap:10px;
    flex-wrap:wrap;
    margin:0;
  }

  /* SEATS */
  .seat{
    position:absolute;
    width:260px;
    padding:10px;
    border-radius:18px;
    background: linear-gradient(180deg, #071215cc, #07121599);
    border:1px solid var(--line);
    box-shadow: 0 14px 40px var(--shadow);
    backdrop-filter: blur(10px);
    z-index:14;
  }
  .seat .top{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom:8px;
  }
  .leftname{
    display:flex;
    align-items:center;
    gap:10px;
    min-width:0;
  }
  .name{
    font-weight:900;
    letter-spacing:.2px;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .tag{
    font-size:12px;
    color:var(--muted);
    border:1px solid var(--line);
    padding:2px 9px;
    border-radius:999px;
    white-space:nowrap;
  }
  .tag.turn{ color:var(--accent); border-color:#63f2c540; }
  .tag.out{ color:var(--danger); border-color:#ff6b6b55; }

  .meta{
    display:flex;
    justify-content:space-between;
    gap:10px;
    font-size:13px;
    color:var(--muted);
    margin-bottom:8px;
  }
  .cards{
    display:flex;
    gap:8px;
    min-height:78px;
  }
  .cards.folded{ filter: grayscale(1); opacity:0.35; }

  .card{
    width:56px; height:76px;
    border-radius:12px;
    background: var(--card);
    color: var(--cardText);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:950;
    letter-spacing:.4px;
    box-shadow: 0 10px 22px #00000055;
    position:relative;
    border:1px solid #0000001c;
    opacity:1;
    transform: translateY(0) scale(1);
  }
  .card.hidden{
    background: linear-gradient(135deg, #153040, #0b1922);
    color:#ffffffaa;
    border-color:#ffffff18;
  }
  body.night .card.hidden{
    background: linear-gradient(135deg, #0b1016, #0a0f14);
    border-color:#ffffff18;
  }
  .card small{
    position:absolute;
    left:8px; top:6px;
    font-size:12px;
    font-weight:950;
    opacity:.92;
  }
  .card .suit{ font-size:22px; }

  .card.deal{
    opacity:0;
    transform: translateY(-10px) scale(0.96);
    animation: popin .26s ease forwards;
  }
  @keyframes popin{ to{ opacity:1; transform: translateY(0) scale(1);} }

  /* Neon highlight for best hand cards */
  .card.neon{
    box-shadow:
      0 10px 22px #00000055,
      0 0 0 2px color-mix(in srgb, var(--neon) 65%, transparent),
      0 0 18px color-mix(in srgb, var(--neon) 55%, transparent),
      0 0 36px color-mix(in srgb, var(--neon2) 35%, transparent);
  }

  .bet{
    margin-top:8px;
    font-size:13px;
    color:var(--warn);
    min-height:16px;
  }

  /* Positions */
  .pos-0{ left:50%; bottom:120px; transform:translateX(-50%); } /* YOU */
  .pos-1{ left:18px; bottom:180px; }
  .pos-2{ left:18px; top:140px; }
  .pos-3{ left:50%; top:120px; transform:translateX(-50%); }
  .pos-4{ right:18px; top:140px; }
  .pos-5{ right:18px; bottom:180px; }

  /* BOTTOM RIGHT ACTIONS (separate buttons) */
  .actions{
    position:absolute;
    right:14px;
    bottom:14px;
    z-index:30;
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:flex-end;
  }
  .actionrow{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }
  .btn{
    padding:10px 14px;
    border-radius:14px;
    border:1px solid var(--line);
    background: var(--btn);
    color:var(--text);
    font-weight:950;
    cursor:pointer;
    box-shadow: 0 10px 28px #00000055;
    backdrop-filter: blur(8px);
    transition: transform .08s ease, border-color .12s ease, filter .12s ease;
    user-select:none;
  }
  .btn:hover{ border-color:#ffffff35; filter:brightness(1.05); }
  .btn:active{ transform: translateY(1px); }
  .btn:disabled{ opacity:.40; cursor:not-allowed; box-shadow:none; }

  .btn-accent{
    background: linear-gradient(180deg, #0d2b24, #071a16);
    border-color:#63f2c540;
  }
  .btn-warn{
    background: linear-gradient(180deg, #2a2416, #19140b);
    border-color:#ffd27a44;
  }
  .btn-danger{
    background: linear-gradient(180deg, #2b1012, #19080a);
    border-color:#ff6b6b55;
  }

  .statusbox{
    padding:10px 12px;
    border-radius:18px;
    background: linear-gradient(180deg, #071215dd, #071215aa);
    border:1px solid var(--line);
    box-shadow: 0 18px 60px var(--shadow);
    backdrop-filter: blur(10px);
    width:min(520px, 92vw);
  }
  .status-top{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    color:var(--muted);
    font-size:13px;
  }
  .status-top b{ color:var(--text); }
  .combobox{
    margin-top:8px;
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap:12px;
    flex-wrap:wrap;
  }
  .combo{
    font-weight:950;
    letter-spacing:.2px;
  }
  .winpct{
    color:var(--accent);
    font-weight:950;
  }

  /* Turn timer */
  .timer{
    margin-top:10px;
    height:10px;
    border-radius:999px;
    background:#00000030;
    border:1px solid var(--line);
    overflow:hidden;
  }
  .timer > div{
    height:100%;
    width:100%;
    background: linear-gradient(90deg, var(--accent), var(--warn));
    transform-origin:left;
    transform:scaleX(1);
  }

  /* Chips visuals */
  .chips{
    display:flex;
    align-items:center;
    gap:10px;
  }
  .stack{
    position:relative;
    width:44px;
    height:30px;
  }
  .chip{
    position:absolute;
    left:0;
    width:44px;
    height:14px;
    border-radius:999px;
    background: radial-gradient(circle at 35% 35%, #ffffff55, #00000000 55%),
                linear-gradient(180deg, #f7d46a, #b07b1c);
    border:1px solid #0000002a;
    box-shadow: 0 8px 18px #00000055;
  }
  body.night .chip{
    background: radial-gradient(circle at 35% 35%, #ffffff55, #00000000 55%),
                linear-gradient(180deg, #9fb3ff, #3b4d9b);
  }
  .stack .chip:nth-child(1){ bottom:0px }
  .stack .chip:nth-child(2){ bottom:6px }
  .stack .chip:nth-child(3){ bottom:12px }
  .stack .chip:nth-child(4){ bottom:18px }
  .stack .chip:nth-child(5){ bottom:24px }
  .stackLabel{
    font-size:12px;
    color:var(--muted);
    white-space:nowrap;
  }

  /* Pot chips in center */
  .potChips{
    margin-top:10px;
    display:flex;
    justify-content:center;
    gap:10px;
    align-items:center;
    color:var(--muted);
    font-size:13px;
  }

  /* Avatars */
  .avatar{
    width:28px; height:28px;
    border-radius:999px;
    border:1px solid var(--line);
    background:#00000030;
    overflow:hidden;
    flex:0 0 auto;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    color:var(--text);
  }
  .avatar img{
    width:100%; height:100%;
    object-fit:cover;
    display:block;
  }

  /* CHIP FLY */
  .chip-fly{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    padding:6px 10px;
    border-radius:999px;
    background:#00000055;
    border:1px solid var(--line);
    color:var(--warn);
    font-weight:950;
    font-size:13px;
    pointer-events:none;
    opacity:0;
    animation: fly .7s ease forwards;
    z-index:40;
  }
  @keyframes fly{
    0% { opacity:0; transform:translate(-50%,-50%) translateY(10px) scale(.95); }
    30%{ opacity:1; }
    100%{ opacity:0; transform:translate(-50%,-50%) translateY(-26px) scale(1); }
  }

  /* OVERLAYS */
  .overlay{
    position:fixed; inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:#00000088;
    z-index:60;
    padding:16px;
  }
  .modal{
    width:min(720px, 96vw);
    border-radius:20px;
    background: linear-gradient(180deg, #071215f2, #071215d8);
    border:1px solid var(--line);
    box-shadow: 0 20px 80px #000000aa;
    padding:14px;
  }
  .modal h2{ margin:0 0 10px; font-size:20px; }
  .small{ font-size:13px; color:var(--muted); line-height:1.35; }
  .field{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }
  .field input[type="text"], .field input[type="number"]{
    width:100%;
    padding:10px 12px;
    border-radius:14px;
    border:1px solid var(--line);
    background:#0a1416;
    color:var(--text);
    outline:none;
    font-weight:900;
  }
  .field input[type="file"]{
    width:100%;
    color:var(--muted);
  }
  .grid3{
    display:grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap:10px;
    margin-top:12px;
  }
  @media (max-width: 760px){
    .grid3{ grid-template-columns:1fr; }
    .pos-0{ bottom:150px; }
  }
  .kv{ display:flex; justify-content:space-between; gap:10px; font-size:13px; color:var(--muted); }
  .kv b{ color:var(--text); }
  .range{ width:100%; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
</style>
</head>

<body>
<div class="table" id="table">
  <div class="hud">
    <span class="pill">üë§ <span id="hudNick">-</span></span>
    <span class="pill">üí∂ EUR: <b id="hudEur">0</b></span>
    <span class="pill">üí∞ Wallet: <b id="hudWalletChips">0</b></span>
    <span class="pill">üÉè <span id="hudStage">IDLE</span></span>
    <span class="pill">Pot: <b id="hudPot">0</b></span>
    <span class="pill">To call: <b id="hudToCall">0</b></span>
    <span class="pill">Dealer: <b id="hudDealer">-</b></span>
  </div>

  <div class="msg" id="msg"></div>

  <div class="center">
    <div class="board" id="board"></div>
    <div class="potChips">
      <div class="stack" id="potStack" aria-hidden="true"></div>
      <div>Pot chips: <b id="potChipsLabel">0</b></div>
    </div>
  </div>

  <!-- Bottom right: separate buttons + status -->
  <div class="actions">
    <div class="statusbox">
      <div class="status-top">
        <span>Raise min: <b id="raiseMinTop">0</b> | max: <b id="raiseMaxTop">0</b></span>
        <span>‚è±Ô∏è <b id="turnLeft">0</b>s</span>
      </div>

      <div class="combobox">
        <div>
          <div class="combo" id="comboName">‚Äî</div>
          <div class="small" id="comboDetail">–ö–æ–º–±–∏–Ω–∞—Ü–∏—è –∏ —à–∞–Ω—Å –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ —Ä–∞–∑–¥–∞—á–∏</div>
        </div>
        <div class="winpct" id="winPct">‚Äî</div>
      </div>

      <div class="timer"><div id="timerBar"></div></div>
      <div class="chips" style="margin-top:10px">
        <div class="stack" id="youStack" aria-hidden="true"></div>
        <div class="stackLabel">Your chips: <b id="youChipsLabel">0</b></div>
      </div>
    </div>

    <div class="actionrow">
      <button class="btn btn-accent" id="btnMenu">‚ò∞ Menu</button>
      <button class="btn btn-warn" id="btnShop">üõí Shop</button>
    </div>
    <div class="actionrow">
      <button class="btn btn-danger" id="btnFold">Fold</button>
      <button class="btn" id="btnCheck">Check</button>
      <button class="btn" id="btnCall">Call</button>
      <button class="btn btn-accent" id="btnRaise">Raise</button>
    </div>
  </div>
</div>

<!-- Nick -->
<div class="overlay" id="nickOverlay">
  <div class="modal">
    <h2>–í–≤–µ–¥–∏ –Ω–∏–∫</h2>
    <div class="field">
      <input id="nickInput" type="text" maxlength="20" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: artrum255" />
      <button class="btn btn-accent" id="nickOk">OK</button>
    </div>
    <div class="small" style="margin-top:8px">
      –ù–æ–≤—ã–π –Ω–∏–∫ –ø–æ–ª—É—á–∞–µ—Ç <b>1000</b> —Ñ–∏—à–µ–∫ –∏ <b>0</b> EUR. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ –Ω–∏–∫—É –≤ –±—Ä–∞—É–∑–µ—Ä–µ.
    </div>
  </div>
</div>

<!-- Menu -->
<div class="overlay" id="menuOverlay">
  <div class="modal">
    <h2>–ú–µ–Ω—é</h2>
    <div class="small">
      ‚Ä¢ –¢—É—Ä–Ω–∏—Ä: –≤—ã–ª–µ—Ç –ø—Ä–∏ 0, +10 EUR –µ—Å–ª–∏ —Ç—ã —á–µ–º–ø–∏–æ–Ω.<br>
      ‚Ä¢ Settings: —Ç–µ–º–∞, –≤—Ä–µ–º—è —Ö–æ–¥–∞, –∑–≤—É–∫, –∞–≤–∞—Ç–∞—Ä.
    </div>
    <div class="grid3">
      <button class="btn btn-accent" id="btnGoTournament">–¢—É—Ä–Ω–∏—Ä</button>
      <button class="btn btn-warn" id="btnGoShop2">–ú–∞–≥–∞–∑–∏–Ω</button>
      <button class="btn" id="btnGoSettings">Settings</button>
    </div>
    <div class="field" style="margin-top:12px; justify-content:flex-end">
      <button class="btn" id="btnCloseMenu">Close</button>
    </div>
  </div>
</div>

<!-- Shop -->
<div class="overlay" id="shopOverlay">
  <div class="modal">
    <h2>üõí –ú–∞–≥–∞–∑–∏–Ω</h2>
    <div class="small">EUR: <b id="shopEur">0</b> | Wallet chips: <b id="shopChips">0</b></div>
    <div class="grid3" style="grid-template-columns:1fr; margin-top:12px">
      <button class="btn btn-accent" data-buy="1000">–ö—É–ø–∏—Ç—å 1 000 chips ‚Äî 10 EUR</button>
      <button class="btn btn-accent" data-buy="10000">–ö—É–ø–∏—Ç—å 10 000 chips ‚Äî 90 EUR</button>
      <button class="btn btn-accent" data-buy="100000">–ö—É–ø–∏—Ç—å 100 000 chips ‚Äî 390 EUR</button>
    </div>
    <div class="field" style="margin-top:12px; justify-content:space-between">
      <button class="btn" id="btnShopBack">‚ò∞ Menu</button>
      <button class="btn" id="btnShopClose">Close</button>
    </div>
  </div>
</div>

<!-- Raise -->
<div class="overlay" id="raiseOverlay">
  <div class="modal">
    <h2>Raise</h2>
    <div class="small">–í—ã–±–µ—Ä–∏ —Å—É–º–º—É ‚Äúraise to‚Äù (–¥–æ –∫–∞–∫–æ–≥–æ –æ–±—â–µ–≥–æ bet –ø–æ–¥–Ω—è—Ç—å).</div>
    <div class="kv" style="margin-top:10px">
      <span>Raise to:</span>
      <span><b id="raiseToLabel">0</b></span>
    </div>
    <input class="range" id="raiseSlider" type="range" min="0" max="0" value="0"/>

    <div class="field" style="margin-top:10px">
      <input id="raiseInput" type="number" min="0" step="1" />
      <button class="btn btn-accent" id="btnRaiseConfirm">Confirm</button>
    </div>

    <div class="field" style="margin-top:10px; justify-content:space-between">
      <button class="btn" id="btnRaiseMin">Min</button>
      <button class="btn" id="btnRaiseHalf">Half</button>
      <button class="btn" id="btnRaiseAll">All-in</button>
      <button class="btn" id="btnRaiseClose">Close</button>
    </div>
  </div>
</div>

<!-- Settings -->
<div class="overlay" id="settingsOverlay">
  <div class="modal">
    <h2>Settings</h2>
    <div class="small">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –ø–æ –Ω–∏–∫—É.</div>

    <div class="grid3" style="grid-template-columns:1fr;">
      <button class="btn btn-accent" id="btnToggleTheme">Toggle Day/Night</button>

      <div style="margin-top:6px">
        <div class="kv"><span>–í—Ä–µ–º—è –Ω–∞ —Ö–æ–¥ (—Å–µ–∫):</span><b id="turnSecLabel">15</b></div>
        <input class="range" id="turnSecSlider" type="range" min="5" max="30" value="15" />
      </div>

      <div style="margin-top:6px">
        <div class="kv"><span>–ó–≤—É–∫:</span><b id="soundLabel">ON</b></div>
        <button class="btn" id="btnToggleSound">Toggle Sound</button>
      </div>

      <div style="margin-top:6px">
        <div class="small">–ê–≤–∞—Ç–∞—Ä (–∑–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∏):</div>
        <input id="avatarFile" type="file" accept="image/*" />
      </div>
    </div>

    <div class="field" style="margin-top:12px; justify-content:space-between">
      <button class="btn" id="btnSettingsBack">‚ò∞ Menu</button>
      <button class="btn" id="btnSettingsClose">Close</button>
    </div>
  </div>
</div>

<script>
/* =========================
   CONFIG
========================= */
const START_CHIPS = 1000;
const SMALL_BLIND = 10;
const BIG_BLIND = 20;
const BOT_COUNT = 5;
const MAX_RAISES_PER_ROUND = 4;
const BOT_THINK_MS = 280;

const STREET_PAUSE_MS = 850; // small pause between streets
const AUTO_NEXT_HAND_MS = 1100; // auto next hand after showdown

const SHOP_PRICES = { 1000:10, 10000:90, 100000:390 };

const SUITS = ["‚ô£","‚ô¶","‚ô•","‚ô†"];
const RANKS = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
const RVAL = Object.fromEntries(RANKS.map((r,i)=>[r, i+2]));

/* Monte Carlo win odds */
const ODDS_ITERS = 1200; // speed vs accuracy

/* =========================
   STATE
========================= */
let nick = null;
let saveKey = null;

/* profile / wallet */
let walletEUR = 0;
let walletChips = 0;

/* settings */
let settingNight = false;
let settingTurnSec = 15;
let settingSound = true;
let settingAvatarDataURL = null;

/* tournament */
let players = [];
let deck = [];
let board = [];
let pot = 0;
let stage = "IDLE"; // PREFLOP/FLOP/TURN/RIVER/SHOWDOWN/IDLE
let dealer = 0, sb = 1, bb = 2;
let current = 0;
let toCall = 0;
let raisesThisRound = 0;
let handInProgress = false;
let awaitingHuman = false;

/* timers */
let botTimer = null;
let streetTimer = null;
let nextHandTimer = null;
let turnTimer = null;
let turnDeadline = 0;

/* ui state */
let bestHandForYou = null; // {cat, name, cardsKeySet:Set}
let winPctForYou = null;

/* =========================
   UI refs
========================= */
const elTable = document.getElementById("table");
const elBoard = document.getElementById("board");
const elMsg = document.getElementById("msg");

const hudNick = document.getElementById("hudNick");
const hudEur = document.getElementById("hudEur");
const hudWalletChips = document.getElementById("hudWalletChips");
const hudStage = document.getElementById("hudStage");
const hudPot = document.getElementById("hudPot");
const hudToCall = document.getElementById("hudToCall");
const hudDealer = document.getElementById("hudDealer");

const potStack = document.getElementById("potStack");
const potChipsLabel = document.getElementById("potChipsLabel");

const youStack = document.getElementById("youStack");
const youChipsLabel = document.getElementById("youChipsLabel");

const comboName = document.getElementById("comboName");
const comboDetail = document.getElementById("comboDetail");
const winPct = document.getElementById("winPct");

const raiseMinTop = document.getElementById("raiseMinTop");
const raiseMaxTop = document.getElementById("raiseMaxTop");

const turnLeft = document.getElementById("turnLeft");
const timerBar = document.getElementById("timerBar");

const btnMenu = document.getElementById("btnMenu");
const btnShop = document.getElementById("btnShop");
const btnFold = document.getElementById("btnFold");
const btnCheck = document.getElementById("btnCheck");
const btnCall = document.getElementById("btnCall");
const btnRaise = document.getElementById("btnRaise");

/* overlays */
const nickOverlay = document.getElementById("nickOverlay");
const nickInput = document.getElementById("nickInput");
const nickOk = document.getElementById("nickOk");

const menuOverlay = document.getElementById("menuOverlay");
const btnGoTournament = document.getElementById("btnGoTournament");
const btnGoShop2 = document.getElementById("btnGoShop2");
const btnGoSettings = document.getElementById("btnGoSettings");
const btnCloseMenu = document.getElementById("btnCloseMenu");

const shopOverlay = document.getElementById("shopOverlay");
const shopEur = document.getElementById("shopEur");
const shopChips = document.getElementById("shopChips");
const btnShopBack = document.getElementById("btnShopBack");
const btnShopClose = document.getElementById("btnShopClose");

const raiseOverlay = document.getElementById("raiseOverlay");
const raiseSlider = document.getElementById("raiseSlider");
const raiseToLabel = document.getElementById("raiseToLabel");
const raiseInput = document.getElementById("raiseInput");
const btnRaiseConfirm = document.getElementById("btnRaiseConfirm");
const btnRaiseClose = document.getElementById("btnRaiseClose");
const btnRaiseMin = document.getElementById("btnRaiseMin");
const btnRaiseHalf = document.getElementById("btnRaiseHalf");
const btnRaiseAll = document.getElementById("btnRaiseAll");

const settingsOverlay = document.getElementById("settingsOverlay");
const btnToggleTheme = document.getElementById("btnToggleTheme");
const turnSecSlider = document.getElementById("turnSecSlider");
const turnSecLabel = document.getElementById("turnSecLabel");
const btnToggleSound = document.getElementById("btnToggleSound");
const soundLabel = document.getElementById("soundLabel");
const avatarFile = document.getElementById("avatarFile");
const btnSettingsBack = document.getElementById("btnSettingsBack");
const btnSettingsClose = document.getElementById("btnSettingsClose");

/* =========================
   UTILS
========================= */
function show(el, yes){ el.style.display = yes ? "flex" : "none"; }
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function cardKey(c){ return c.r + c.s; }

function chipFly(text){
  const el = document.createElement("div");
  el.className = "chip-fly";
  el.textContent = text;
  elTable.appendChild(el);
  setTimeout(()=>el.remove(), 750);
}

/* create simple stack of up to 5 chips depending on size */
function renderStack(el, amount){
  el.innerHTML = "";
  const levels = amount <= 0 ? 0 : (amount < 50 ? 1 : amount < 200 ? 2 : amount < 600 ? 3 : amount < 1500 ? 4 : 5);
  for(let i=0;i<levels;i++){
    const c = document.createElement("div");
    c.className = "chip";
    el.appendChild(c);
  }
}

/* =========================
   SOUND (WebAudio, no files)
========================= */
let audioCtx = null;
function ensureAudio(){
  if(!settingSound) return;
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if(audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
}
function beep(freq, dur=0.06, type="sine", vol=0.06){
  if(!settingSound) return;
  ensureAudio();
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = 0.0001;
  o.connect(g);
  g.connect(audioCtx.destination);

  const t = audioCtx.currentTime;
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(vol, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t+dur);

  o.start(t);
  o.stop(t+dur+0.02);
}
const SFX = {
  deal(){ beep(520, 0.04, "triangle", 0.04); },
  chip(){ beep(280, 0.06, "square", 0.035); },
  click(){ beep(720, 0.03, "sine", 0.03); },
  win(){ beep(440, 0.08, "sine", 0.05); setTimeout(()=>beep(660,0.08,"sine",0.05), 70); }
};

/* =========================
   PERSISTENCE
========================= */
function keyForNick(n){ return `poker_fx_${n.toLowerCase()}`; }

function saveAll(){
  if(!saveKey) return;
  const state = {
    v:1,
    nick,
    walletEUR, walletChips,
    settings: {
      night: settingNight,
      turnSec: settingTurnSec,
      sound: settingSound,
      avatar: settingAvatarDataURL
    },
    tournament: {
      players, deck, board, pot, stage,
      dealer, sb, bb, current, toCall, raisesThisRound,
      handInProgress
    }
  };
  localStorage.setItem(saveKey, JSON.stringify(state));
  localStorage.setItem("poker_last_nick", nick);
}

function loadAll(n){
  const raw = localStorage.getItem(keyForNick(n));
  if(!raw) return null;
  try { return JSON.parse(raw); } catch { return null; }
}

function applyTheme(){
  document.body.classList.toggle("night", !!settingNight);
  document.documentElement.style.setProperty("--turnSec", String(settingTurnSec));
}

/* =========================
   DECK / PLAYERS
========================= */
function newDeck(){
  const d = [];
  for(const s of SUITS) for(const r of RANKS) d.push({r,s});
  for(let i=d.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}

function nextActiveIndex(from){
  const n = players.length;
  for(let k=1;k<=n;k++){
    const i = (from + k) % n;
    if(!players[i].out && !players[i].folded) return i;
  }
  return from;
}
function nextNotOutIndex(from){
  const n = players.length;
  for(let k=1;k<=n;k++){
    const i = (from + k) % n;
    if(!players[i].out) return i;
  }
  return from;
}
function inHandPlayers(){ return players.filter(p => !p.out && !p.folded); }
function alivePlayers(){ return players.filter(p => !p.out); }
function onlyOneLeftInHand(){ return inHandPlayers().length === 1; }

/* bot avatars = emoji (rendered as text in avatar circle) */
const BOT_EMOJI = ["ü§ñ","ü¶ä","üê∫","üêØ","ü¶Å","üê∏","ü¶â","ü¶à","üêµ","üêº"];

/* =========================
   EVALUATION (best 5 from 7)
========================= */
function eval5(cards){
  // returns {cat, tiebreak[]} like classic
  const ranks = cards.map(c=>RVAL[c.r]).sort((a,b)=>b-a);
  const suits = cards.map(c=>c.s);
  const countMap = new Map();
  for(const r of ranks) countMap.set(r, (countMap.get(r)||0)+1);

  const isFlush = suits.every(s=>s===suits[0]);
  const unique = [...new Set(ranks)].sort((a,b)=>b-a);

  const straightHigh = (arrDesc)=>{
    const set = new Set(arrDesc);
    if(set.has(14)&&set.has(5)&&set.has(4)&&set.has(3)&&set.has(2)) return 5;
    for(let hi=14;hi>=5;hi--){
      let ok=true;
      for(let d=0;d<5;d++) if(!set.has(hi-d)) { ok=false; break; }
      if(ok) return hi;
    }
    return 0;
  };

  const st = straightHigh(unique);

  if(isFlush && st) return {cat:8, tiebreak:[st]}; // straight flush

  const groups = [...countMap.entries()].map(([r,c])=>({r,c}))
    .sort((a,b)=>(b.c-a.c)||(b.r-a.r));
  const counts = groups.map(g=>g.c);

  if(counts[0]===4){
    const quad = groups[0].r;
    const kicker = unique.find(x=>x!==quad);
    return {cat:7, tiebreak:[quad,kicker]};
  }
  if(counts[0]===3 && counts[1]===2){
    return {cat:6, tiebreak:[groups[0].r, groups[1].r]};
  }
  if(isFlush) return {cat:5, tiebreak:ranks};
  if(st) return {cat:4, tiebreak:[st]};
  if(counts[0]===3){
    const trip = groups[0].r;
    const kick = unique.filter(x=>x!==trip);
    return {cat:3, tiebreak:[trip, kick[0], kick[1]]};
  }
  if(counts[0]===2 && counts[1]===2){
    const p1 = groups[0].r, p2 = groups[1].r;
    const kicker = unique.find(x=>x!==p1 && x!==p2);
    return {cat:2, tiebreak:[Math.max(p1,p2), Math.min(p1,p2), kicker]};
  }
  if(counts[0]===2){
    const p = groups[0].r;
    const kick = unique.filter(x=>x!==p);
    return {cat:1, tiebreak:[p, kick[0], kick[1], kick[2]]};
  }
  return {cat:0, tiebreak:ranks};
}
function compareEval(a,b){
  if(a.cat!==b.cat) return a.cat-b.cat;
  for(let i=0;i<Math.max(a.tiebreak.length,b.tiebreak.length);i++){
    const x=a.tiebreak[i]||0, y=b.tiebreak[i]||0;
    if(x!==y) return x-y;
  }
  return 0;
}
function catName(cat){
  return ["High Card","Pair","Two Pair","Trips","Straight","Flush","Full House","Quads","Straight Flush"][cat] || "‚Äî";
}

function best5of7(seven){
  // brute force choose 5 from 7 (21 combos)
  let best = null;
  let bestCards = null;
  for(let a=0;a<7;a++){
    for(let b=a+1;b<7;b++){
      const five = [];
      for(let i=0;i<7;i++){
        if(i!==a && i!==b) five.push(seven[i]);
      }
      const e = eval5(five);
      if(!best || compareEval(best, e) < 0){
        best = e;
        bestCards = five;
      }
    }
  }
  return {e:best, cards:bestCards};
}

/* =========================
   ODDS (Monte Carlo)
   - uses known bot hole cards (local game)
========================= */
function computeWinOddsForYou(){
  const you = players[0];
  if(!handInProgress || you.out || you.folded) return null;
  const actives = players.filter(p=>!p.out && !p.folded);
  if(actives.length <= 1) return 100;

  // Build remaining deck (remove known hole + board)
  const used = new Set();
  for(const p of players){
    for(const c of p.hand||[]) if(c) used.add(cardKey(c));
  }
  for(const c of board) if(c) used.add(cardKey(c));

  const full = [];
  for(const s of SUITS) for(const r of RANKS){
    const k = r+s;
    if(!used.has(k)) full.push({r,s});
  }

  let wins = 0, ties = 0, total = 0;
  const needBoard = 5 - board.length;

  for(let it=0; it<ODDS_ITERS; it++){
    // sample remaining cards
    // shuffle pick
    const pool = full.slice();
    for(let i=pool.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      [pool[i],pool[j]] = [pool[j],pool[i]];
    }
    const runout = pool.slice(0, needBoard);
    const finalBoard = board.concat(runout);

    const youBest = best5of7(you.hand.concat(finalBoard)).e;

    let bestE = youBest;
    let bestCount = 1;
    let youIsBest = true;

    for(const p of actives){
      if(p===you) continue;
      const e = best5of7(p.hand.concat(finalBoard)).e;
      const cmp = compareEval(bestE, e);
      if(cmp < 0){
        bestE = e;
        bestCount = 1;
        youIsBest = false;
      } else if(cmp === 0){
        bestCount++;
        if(compareEval(e, youBest)===0) {
          // tie for best includes you
          // keep youIsBest as is
        } else {
          youIsBest = false;
        }
      }
    }

    total++;
    if(compareEval(bestE, youBest)===0){
      // you is at least tied best
      // count if someone else shares best
      const tieN = actives.filter(p=>{
        const e = best5of7(p.hand.concat(finalBoard)).e;
        return compareEval(e, bestE)===0;
      }).length;
      if(tieN === 1) wins++;
      else ties++;
    }
  }

  const pct = ((wins + ties*0.5) / Math.max(1,total)) * 100;
  return Math.round(pct);
}

/* =========================
   GAME FLOW
========================= */
function resetRoundBets(){
  for(const p of players) p.bet = 0;
  toCall = 0;
  raisesThisRound = 0;
}
function postBlind(i, amount){
  const p = players[i];
  const pay = Math.min(amount, p.chips);
  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  if(pay>0){ chipFly(`-${pay}`); SFX.chip(); }
}
function bettingRoundComplete(){
  const ps = inHandPlayers();
  for(const p of ps){
    if(p.chips === 0) continue;
    if(p.bet !== toCall) return false;
  }
  return true;
}
function minRaiseTo(){ return toCall + BIG_BLIND; }

function cleanupEliminations(){
  for(const p of players){
    if(!p.out && p.chips <= 0){
      p.out = true;
      p.chips = 0;
    }
  }
}
function checkTournamentWinner(){
  const alive = alivePlayers();
  if(alive.length === 1){
    const w = alive[0];
    elMsg.textContent = `üèÜ CHAMPION: ${w.name}` + (w.isBot ? "" : "  +10 EUR");
    if(!w.isBot){
      walletEUR += 10;
      chipFly("+10 EUR");
      SFX.win();
      saveAll();
      renderHUD();
    }
    handInProgress = false;
    stage = "IDLE";
    awaitingHuman = false;
    stopTurnTimer();
    return true;
  }
  return false;
}

function createTournamentIfNeeded(){
  if(players.length && players[0] && players[0].name === nick) return;

  players = [];
  players.push({
    name:nick, isBot:false,
    chips:walletChips, bet:0,
    folded:false, out:false,
    hand:[],
    avatar: settingAvatarDataURL
  });
  for(let i=1;i<=BOT_COUNT;i++){
    players.push({
      name:`BOT${i}`, isBot:true,
      chips:walletChips, bet:0,
      folded:false, out:false,
      hand:[],
      avatar: BOT_EMOJI[(i-1)%BOT_EMOJI.length]
    });
  }
  dealer = 0; sb = 1; bb = 2;
  stage = "IDLE";
  pot = 0;
  board = [];
  toCall = 0; raisesThisRound = 0;
  handInProgress = false;
  awaitingHuman = false;
  saveAll();
}

function startHandAuto(){
  if(checkTournamentWinner()) return;
  cleanupEliminations();
  if(alivePlayers().length < 2) return;

  handInProgress = true;
  deck = newDeck();
  board = [];
  pot = 0;
  bestHandForYou = null;
  winPctForYou = null;

  for(const p of players){
    p.folded = false; p.bet = 0; p.hand = [];
  }

  dealer = nextNotOutIndex(dealer);
  sb = nextNotOutIndex(dealer);
  bb = nextNotOutIndex(sb);

  // deal with tiny sound
  for(let r=0;r<2;r++){
    for(const p of players){
      if(!p.out){
        p.hand.push(deck.pop());
      }
    }
  }
  SFX.deal();

  resetRoundBets();
  postBlind(sb, SMALL_BLIND);
  postBlind(bb, BIG_BLIND);
  toCall = Math.max(players[sb].bet, players[bb].bet);

  stage = "PREFLOP";
  current = nextActiveIndex(bb);
  awaitingHuman = false;

  elMsg.textContent = "–ù–æ–≤–∞—è —Ä–∞–∑–¥–∞—á–∞‚Ä¶";
  saveAll();
  render();
  tick();
}

function pauseStreet(text, fn){
  clearTimeout(streetTimer);
  elMsg.textContent = text;
  streetTimer = setTimeout(()=>fn(), STREET_PAUSE_MS);
}

function advanceStage(){
  stopTurnTimer();
  pauseStreet(
    stage==="PREFLOP" ? "–§–ª–æ–ø‚Ä¶" :
    stage==="FLOP" ? "–¢—ë—Ä–Ω‚Ä¶" :
    stage==="TURN" ? "–†–∏–≤–µ—Ä‚Ä¶" :
    stage==="RIVER" ? "–®–æ—É–¥–∞—É–Ω‚Ä¶" : "‚Ä¶",
    ()=>{
      for(const p of players) p.bet = 0;
      toCall = 0;
      raisesThisRound = 0;

      if(stage==="PREFLOP"){ board.push(deck.pop(), deck.pop(), deck.pop()); stage="FLOP"; SFX.deal(); }
      else if(stage==="FLOP"){ board.push(deck.pop()); stage="TURN"; SFX.deal(); }
      else if(stage==="TURN"){ board.push(deck.pop()); stage="RIVER"; SFX.deal(); }
      else if(stage==="RIVER"){ stage="SHOWDOWN"; }

      current = nextActiveIndex(dealer);
      awaitingHuman = false;

      saveAll();
      render();

      if(stage==="SHOWDOWN"){
        pauseStreet("–û—Ç–∫—Ä—ã–≤–∞–µ–º –∫–∞—Ä—Ç—ã‚Ä¶", doShowdown);
      } else {
        tick();
      }
    }
  );
}

function doShowdown(){
  stopTurnTimer();

  const contenders = inHandPlayers();
  if(contenders.length === 1){
    awardPotTo(players.indexOf(contenders[0]), "(everyone folded)");
    return;
  }

  const evals = contenders.map(p=>({
    p,
    best: best5of7(p.hand.concat(board))
  }));
  evals.sort((a,b)=>compareEval(a.best.e, b.best.e));
  const bestE = evals[evals.length-1].best.e;
  const winners = evals.filter(x=>compareEval(x.best.e, bestE)===0).map(x=>x.p);

  const share = Math.floor(pot / winners.length);
  let rem = pot - share*winners.length;
  for(const w of winners){
    w.chips += share;
    if(rem>0){ w.chips += 1; rem--; }
  }

  elMsg.textContent = `Showdown: ${winners.map(w=>w.name).join(", ")} wins`;
  chipFly(`+${pot}`);
  SFX.chip();
  pot = 0;

  handInProgress = false;
  stage = "IDLE";
  awaitingHuman = false;

  cleanupEliminations();
  checkTournamentWinner();

  // auto next hand
  saveAll();
  render();
  scheduleNextHand();
}

function scheduleNextHand(){
  clearTimeout(nextHandTimer);
  if(checkTournamentWinner()) return;
  nextHandTimer = setTimeout(()=>startHandAuto(), AUTO_NEXT_HAND_MS);
}

function awardPotTo(idx, reason){
  players[idx].chips += pot;
  chipFly(`+${pot}`);
  SFX.chip();
  elMsg.textContent = `${players[idx].name} wins ${pot} ${reason||""}`.trim();
  pot = 0;

  handInProgress = false;
  stage = "IDLE";
  awaitingHuman = false;

  cleanupEliminations();
  checkTournamentWinner();

  saveAll();
  render();
  scheduleNextHand();
}

function playerFold(i){
  players[i].folded = true;
  elMsg.textContent = `${players[i].name} folds`;
  stopTurnTimer();
  saveAll();
  render();
  if(onlyOneLeftInHand()){
    awardPotTo(players.indexOf(inHandPlayers()[0]), "(everyone folded)");
    return;
  }
  current = nextActiveIndex(i);
  tick();
}

function playerCheck(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  if(need !== 0) return;
  elMsg.textContent = `${p.name} checks`;
  stopTurnTimer();
  saveAll();
  render();
  current = nextActiveIndex(i);
  if(bettingRoundComplete()) return advanceStage();
  tick();
}

function playerCall(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  if(need<=0) return playerCheck(i);
  const pay = Math.min(need, p.chips);
  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  if(pay>0){ chipFly(`-${pay}`); SFX.chip(); }
  elMsg.textContent = `${p.name} calls ${pay}`;
  stopTurnTimer();
  saveAll();
  render();
  current = nextActiveIndex(i);
  if(bettingRoundComplete()) return advanceStage();
  tick();
}

function playerRaiseTo(i, raiseTo){
  if(raisesThisRound >= MAX_RAISES_PER_ROUND) return playerCall(i);
  const p = players[i];

  raiseTo = Math.max(raiseTo, minRaiseTo());
  raiseTo = Math.min(raiseTo, p.bet + p.chips);

  const add = Math.max(0, raiseTo - p.bet);
  const pay = Math.min(add, p.chips);
  if(pay<=0) return playerCall(i);

  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  toCall = Math.max(toCall, p.bet);
  raisesThisRound++;

  chipFly(`-${pay}`);
  SFX.chip();
  elMsg.textContent = `${p.name} raises to ${p.bet}`;
  stopTurnTimer();
  saveAll();
  render();

  current = nextActiveIndex(i);
  tick();
}

/* =========================
   BOT AI (simple but ok)
========================= */
function botDecision(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  const stack = Math.max(1, p.chips);
  const potOdds = need / Math.max(1, pot + need);
  const pressure = need / (stack + 1);

  if(stage==="PREFLOP"){
    const a = RVAL[p.hand[0].r], b = RVAL[p.hand[1].r];
    const pair = p.hand[0].r === p.hand[1].r;
    const suited = p.hand[0].s === p.hand[1].s;
    const gap = Math.abs(a-b);
    const high = Math.max(a,b);

    let score = 0.0;
    score += pair ? 0.55 : 0.0;
    score += (high/14)*0.30;
    score += suited ? 0.08 : 0.0;
    score += (gap<=2) ? 0.06 : 0.0;
    score += (high>=12) ? 0.06 : 0.0;
    score += (Math.random()-0.5)*0.06;

    if(need===0){
      if(score>0.72 && raisesThisRound<MAX_RAISES_PER_ROUND && Math.random()<0.35) return "RAISE";
      return "CHECK";
    }
    if(score < 0.33 && (pressure>0.12 || potOdds>0.28) && Math.random()<0.80) return "FOLD";
    if(score > 0.74 && raisesThisRound<MAX_RAISES_PER_ROUND && p.chips > need + BIG_BLIND && Math.random()<0.50) return "RAISE";
    return "CALL";
  }

  const e = best5of7(p.hand.concat(board)).e;
  let strength = (e.cat/8) + (Math.random()-0.5)*0.08;

  if(need===0){
    if(strength > 0.62 && raisesThisRound<MAX_RAISES_PER_ROUND && Math.random()<0.28) return "RAISE";
    return "CHECK";
  }
  if(strength < 0.25 && (pressure>0.14 || potOdds>0.30) && Math.random()<0.80) return "FOLD";
  if(strength > 0.70 && raisesThisRound<MAX_RAISES_PER_ROUND && Math.random()<0.40) return "RAISE";
  if(potOdds < 0.34) return "CALL";
  if(Math.random()<0.15) return "FOLD";
  return "CALL";
}

function botAct(){
  if(!handInProgress) return;
  if(players[current].out || players[current].folded) current = nextActiveIndex(current);
  if(onlyOneLeftInHand()) return awardPotTo(players.indexOf(inHandPlayers()[0]), "(everyone folded)");

  const d = botDecision(current);
  if(d==="FOLD") playerFold(current);
  else if(d==="CHECK") playerCheck(current);
  else if(d==="RAISE"){
    const p = players[current];
    const min = minRaiseTo();
    const maxTo = p.bet + p.chips;
    let target = min + Math.floor(Math.random()*3)*BIG_BLIND;
    const e = best5of7(p.hand.concat(board)).e;
    if(e.cat>=4) target += BIG_BLIND*3;
    if(e.cat>=6) target += BIG_BLIND*5;
    target = clamp(target, min, maxTo);
    playerRaiseTo(current, target);
  } else {
    playerCall(current);
  }
}

/* =========================
   TURN TIMER (15s default, configurable)
========================= */
function stopTurnTimer(){
  clearInterval(turnTimer);
  turnTimer = null;
  turnDeadline = 0;
  turnLeft.textContent = "0";
  timerBar.style.transform = "scaleX(0)";
}

function startTurnTimer(){
  stopTurnTimer();
  const secs = settingTurnSec;
  const start = Date.now();
  turnDeadline = start + secs*1000;

  const tickUi = ()=>{
    const now = Date.now();
    const leftMs = Math.max(0, turnDeadline - now);
    const left = Math.ceil(leftMs/1000);
    turnLeft.textContent = String(left);
    const t = Math.max(0, Math.min(1, leftMs/(secs*1000)));
    timerBar.style.transform = `scaleX(${t})`;

    if(leftMs <= 0){
      // auto-action
      stopTurnTimer();
      autoActionOnTimeout();
    }
  };
  tickUi();
  turnTimer = setInterval(tickUi, 120);
}

function autoActionOnTimeout(){
  // If your turn: auto-check if possible else auto-fold
  if(!handInProgress || current!==0 || players[0].folded || players[0].out) return;
  const you = players[0];
  const need = Math.max(0, toCall - you.bet);
  if(need===0){
    elMsg.textContent = "‚è±Ô∏è Time out ‚Üí auto CHECK";
    playerCheck(0);
  } else {
    elMsg.textContent = "‚è±Ô∏è Time out ‚Üí auto FOLD";
    playerFold(0);
  }
}

/* =========================
   UI + RENDER
========================= */
function renderHUD(){
  hudNick.textContent = nick ?? "-";
  hudEur.textContent = String(walletEUR);
  hudWalletChips.textContent = String(walletChips);
  hudStage.textContent = stage;
  hudPot.textContent = String(pot);
  hudToCall.textContent = String(toCall);
  hudDealer.textContent = (players[dealer] ? players[dealer].name : "-");
  potChipsLabel.textContent = String(pot);
  renderStack(potStack, pot);

  const you = players[0];
  youChipsLabel.textContent = you ? String(you.chips) : "0";
  renderStack(youStack, you ? you.chips : 0);
}

function makeAvatarEl(avatarVal){
  const el = document.createElement("div");
  el.className = "avatar";
  if(!avatarVal){
    el.textContent = "üôÇ";
    return el;
  }
  // if starts with "data:" it's image
  if(typeof avatarVal === "string" && avatarVal.startsWith("data:")){
    const img = document.createElement("img");
    img.src = avatarVal;
    el.appendChild(img);
    return el;
  }
  // else emoji
  el.textContent = avatarVal;
  return el;
}

function makeCardEl(c, opts){
  const {hidden=false, animate=false, neon=false} = opts || {};
  const el = document.createElement("
