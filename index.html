<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Poker ‚Äî Menu + Tournament + Shop</title>
<style>
  :root{
    --bg:#07110c;
    --felt:#146b3a;
    --felt2:#0d4f2b;
    --panel:#0b0f12e8;
    --text:#e9f2ec;
    --muted:#b9c9bf;
    --accent:#66ffb3;
    --danger:#ff6b6b;
    --warn:#ffd166;
    --card:#f6f7fb;
    --cardText:#101316;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    background: radial-gradient(1200px 700px at 50% 35%, #174a33, var(--bg));
    color:var(--text);
    overflow:hidden;
  }

  /* FULLSCREEN TABLE */
  .table{
    position:fixed;
    inset:0;
    background: radial-gradient(120% 100% at 50% 40%, var(--felt), var(--felt2));
    overflow:hidden;
  }
  .table::before{
    content:"";
    position:absolute; inset: min(4vh, 28px);
    border-radius:999px;
    border:2px solid #ffffff1c;
    pointer-events:none;
  }

  /* HUD TOP */
  .hud{
    position:absolute;
    top:14px; left:50%;
    transform:translateX(-50%);
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:center;
    padding:8px;
    z-index:5;
  }
  .pill{
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding:7px 11px;
    border-radius:999px;
    background:#00000035;
    border:1px solid #ffffff12;
    color:var(--muted);
    font-size:14px;
    backdrop-filter: blur(6px);
  }
  .pill b{color:var(--text)}
  .msg{
    position:absolute;
    left:50%; top:92px;
    transform:translateX(-50%);
    width:min(720px, 94vw);
    text-align:center;
    font-size:14px;
    color:var(--text);
    opacity:.95;
    z-index:5;
    min-height:18px;
  }

  /* BOARD */
  .center{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:min(720px, 92vw);
    text-align:center;
    z-index:3;
  }
  .board{
    display:flex;
    justify-content:center;
    gap:10px;
    flex-wrap:wrap;
    margin:0;
  }

  /* BIG SHOP BUTTON LEFT CENTER */
  .shop-fab{
    position:absolute;
    left:18px;
    top:50%;
    transform:translateY(-50%);
    z-index:6;
  }
  .shop-fab button{
    width:180px;
    padding:14px 14px;
    border-radius:18px;
    border:1px solid #ffffff22;
    background: linear-gradient(180deg, #1a3b2b, #0b1f16);
    color:var(--text);
    font-weight:900;
    cursor:pointer;
    box-shadow: 0 14px 40px #00000066;
  }
  .shop-fab button:hover{ border-color:#66ffb350; }

  /* RIGHT PANEL (floating) */
  .panel{
    position:absolute;
    right:14px; top:14px;
    width:min(360px, 92vw);
    max-height: calc(100vh - 28px);
    padding:14px;
    border-radius:18px;
    background: var(--panel);
    border:1px solid #ffffff14;
    box-shadow: 0 18px 70px #00000088;
    backdrop-filter: blur(8px);
    z-index:6;
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .panel h3{ margin:0; font-size:18px; }
  .controls{ display:grid; gap:8px; }
  button{
    padding:10px 12px;
    border-radius:12px;
    border:1px solid #ffffff18;
    background:#0b0f12;
    color:var(--text);
    font-weight:800;
    cursor:pointer;
  }
  button:hover{ border-color:#ffffff35; }
  button:disabled{ opacity:.45; cursor:not-allowed; }
  .btn-accent{
    background: linear-gradient(180deg, #1a3b2b, #0b1f16);
    border-color:#66ffb333;
  }

  .small{ font-size:13px; color:var(--muted); line-height:1.35; }
  .kv{ display:flex; justify-content:space-between; gap:10px; font-size:13px; color:var(--muted); }
  .kv b{ color:var(--text); }
  input[type="range"]{ width:100%; }

  .log{
    overflow:auto;
    padding:10px;
    border-radius:14px;
    background:#00000022;
    border:1px solid #ffffff12;
    font-size:13px;
    color:var(--muted);
    white-space:pre-wrap;
    flex:1;
    min-height:120px;
  }

  /* SEATS */
  .seat{
    position:absolute;
    width:240px;
    padding:10px;
    border-radius:16px;
    background: linear-gradient(180deg, #0b0f12cc, #0b0f1299);
    border:1px solid #ffffff14;
    box-shadow: 0 10px 30px #00000055;
    backdrop-filter: blur(6px);
    z-index:4;
  }
  .seat .top{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    margin-bottom:8px;
  }
  .name{ font-weight:900; letter-spacing:.2px; }
  .tag{
    font-size:12px;
    color:var(--muted);
    border:1px solid #ffffff18;
    padding:2px 8px;
    border-radius:999px;
    white-space:nowrap;
  }
  .tag.turn{ color:var(--accent); border-color:#66ffb340; }
  .tag.out{ color:var(--danger); border-color:#ff6b6b55; }

  .meta{
    display:flex;
    justify-content:space-between;
    gap:10px;
    font-size:13px;
    color:var(--muted);
    margin-bottom:8px;
  }

  .cards{
    display:flex;
    gap:8px;
    min-height:78px;
  }
  .cards.folded{
    filter: grayscale(1);
    opacity:0.45;
  }

  .card{
    width:56px;
    height:76px;
    border-radius:10px;
    background: var(--card);
    color:var(--cardText);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    letter-spacing:.4px;
    box-shadow: 0 8px 18px #00000055;
    position:relative;
    border:1px solid #00000022;
    opacity:1;
    transform: translateY(0) scale(1);
  }
  .card.hidden{
    background: linear-gradient(135deg, #1b2a3a, #0e1722);
    color:#ffffffaa;
    border-color:#ffffff1a;
  }
  .card small{
    position:absolute;
    left:8px; top:6px;
    font-size:12px;
    font-weight:900;
    opacity:.9;
  }
  .card .suit{ font-size:22px; }
  .card.deal{
    opacity:0;
    transform: translateY(-10px) scale(0.96);
    animation: popin .28s ease forwards;
  }
  @keyframes popin{
    to{ opacity:1; transform: translateY(0) scale(1); }
  }

  .bet{ margin-top:8px; font-size:13px; color:var(--warn); min-height:16px; }

  .pos-0{ left:50%; bottom:14px; transform:translateX(-50%); }
  .pos-1{ left:18px; bottom:160px; }
  .pos-2{ left:18px; top:140px; }
  .pos-3{ left:50%; top:120px; transform:translateX(-50%); }
  .pos-4{ right:18px; top:140px; }
  .pos-5{ right:18px; bottom:160px; }

  /* CHIP FLY */
  .chip-fly{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    padding:6px 10px;
    border-radius:999px;
    background:#00000055;
    border:1px solid #ffffff1a;
    color:var(--warn);
    font-weight:900;
    font-size:13px;
    pointer-events:none;
    opacity:0;
    animation: fly .7s ease forwards;
    z-index:10;
  }
  @keyframes fly{
    0% { opacity:0; transform:translate(-50%,-50%) translateY(10px) scale(.95); }
    30%{ opacity:1; }
    100%{ opacity:0; transform:translate(-50%,-50%) translateY(-26px) scale(1); }
  }

  /* OVERLAYS (Menu + Modals) */
  .overlay{
    position:fixed; inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:#00000088;
    z-index:50;
    padding:16px;
  }
  .cardbox{
    width:min(620px, 96vw);
    border-radius:18px;
    background: linear-gradient(180deg, #0b0f12f0, #0b0f12cc);
    border:1px solid #ffffff18;
    box-shadow: 0 20px 80px #000000aa;
    padding:14px;
  }
  .cardbox h2{ margin:0 0 10px; font-size:20px; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .field{ display:flex; gap:8px; align-items:center; }
  .field input{
    width:100%;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid #ffffff20;
    background:#0b0f12;
    color:var(--text);
    outline:none;
    font-weight:800;
  }
  .menu-buttons{
    display:grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap:10px;
    margin-top:12px;
  }
  @media (max-width: 720px){
    .menu-buttons{ grid-template-columns:1fr; }
    .panel{ right:10px; left:10px; width:auto; }
    .shop-fab{ left:10px; }
    .shop-fab button{ width:150px; }
  }

  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

  /* Play lobby */
  .lobby{
    display:grid;
    gap:10px;
    margin-top:10px;
  }
  .lobby .tbl{
    border:1px solid #ffffff18;
    border-radius:14px;
    padding:10px;
    background:#00000022;
  }
  .tbl-head{
    display:flex; justify-content:space-between; align-items:center;
    gap:10px; flex-wrap:wrap;
  }
  .seats-mini{
    display:flex; gap:6px; flex-wrap:wrap; margin-top:8px;
  }
  .seat-mini{
    padding:6px 8px;
    border:1px solid #ffffff18;
    border-radius:999px;
    color:var(--muted);
    font-size:12px;
    background:#00000022;
  }
  .seat-mini.you{ color:var(--accent); border-color:#66ffb340; }
</style>
</head>

<body>
  <div class="table" id="table">
    <div class="hud">
      <span class="pill">üë§ <span id="hudNick">-</span></span>
      <span class="pill">üí∂ EUR: <b id="hudEur">0</b></span>
      <span class="pill">üí∞ Chips: <b id="hudChips">0</b></span>
      <span class="pill">üÉè <span id="hudStage">IDLE</span></span>
      <span class="pill">Pot: <b id="hudPot">0</b></span>
      <span class="pill">To call: <b id="hudToCall">0</b></span>
      <span class="pill">Dealer: <b id="hudDealer">-</b></span>
    </div>

    <div class="msg" id="msg"></div>

    <div class="shop-fab">
      <button id="btnShopBig">üõí –ú–ê–ì–ê–ó–ò–ù</button>
    </div>

    <div class="center">
      <div class="board" id="board"></div>
    </div>

    <div class="panel" id="panel">
      <h3 id="panelTitle">Tournament</h3>

      <div class="controls">
        <button class="btn-accent" id="btnMenu">‚ò∞ Menu</button>
        <button class="btn-accent" id="btnStartResume">Start / Resume</button>
        <button id="btnNextHand">Next Hand</button>
        <button id="btnFold">Fold</button>
        <button id="btnCall">Call / Check</button>
        <button id="btnRaise">Raise</button>
      </div>

      <div class="small" id="raiseBox">
        <b>Raise —Å—É–º–º–∞:</b>
        <div class="kv"><span>Raise to:</span><span><b id="raiseToLabel">0</b></span></div>
        <input id="raiseSlider" type="range" min="0" max="0" value="0" />
        <div class="kv"><span>Min:</span><b id="raiseMin">0</b><span>Max:</span><b id="raiseMax">0</b></div>
      </div>

      <div class="small" id="infoBox">
        <b>EUR:</b> +10 –∑–∞ –≤—ã–∏–≥—Ä–∞–Ω–Ω—ã–π —Ç—É—Ä–Ω–∏—Ä. <br>
        <b>–í—ã–ª–µ—Ç:</b> Chips=0 ‚Üí OUT. –ò–≥—Ä–∞ –¥–æ 1 –ø–æ–±–µ–¥–∏—Ç–µ–ª—è.
      </div>

      <div class="log" id="log"></div>
    </div>
  </div>

  <!-- MENU -->
  <div class="overlay" id="menuOverlay">
    <div class="cardbox">
      <h2>–ú–µ–Ω—é</h2>
      <div class="small">
        –í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º. <br>
        ‚Äú–ò–≥—Ä–∞—Ç—å‚Äù ‚Äî —ç—Ç–æ <b>–ª–æ–±–±–∏-–∏–º–∏—Ç–∞—Ü–∏—è</b> –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞ (–Ω–∞—Å—Ç–æ—è—â–∏–π –æ–Ω–ª–∞–π–Ω —Ç—Ä–µ–±—É–µ—Ç –±—ç–∫–µ–Ω–¥).
      </div>
      <div class="menu-buttons">
        <button class="btn-accent" id="btnGoPlay">–ò–≥—Ä–∞—Ç—å</button>
        <button class="btn-accent" id="btnGoShop">–ú–∞–≥–∞–∑–∏–Ω</button>
        <button class="btn-accent" id="btnGoTournament">–¢—É—Ä–Ω–∏—Ä</button>
      </div>
      <div class="row" style="margin-top:10px; justify-content:flex-end">
        <button id="btnCloseMenu">Close</button>
      </div>
    </div>
  </div>

  <!-- NICK (ASK IMMEDIATELY) -->
  <div class="overlay" id="nickOverlay">
    <div class="cardbox">
      <h2>–í–≤–µ–¥–∏ –Ω–∏–∫</h2>
      <div class="field">
        <input id="nickInput" maxlength="20" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: artrum255" />
        <button class="btn-accent" id="nickOk">OK</button>
      </div>
      <div class="small" style="margin-top:8px">
        –î–ª—è –Ω–æ–≤–æ–≥–æ –Ω–∏–∫–∞: <b>1000 chips</b> –∏ <b>0 EUR</b>.<br>
        –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–¥—ë—Ç –≤ –±—Ä–∞—É–∑–µ—Ä–µ (LocalStorage).
      </div>
    </div>
  </div>

  <!-- SHOP -->
  <div class="overlay" id="shopOverlay">
    <div class="cardbox">
      <h2>üõí –ú–∞–≥–∞–∑–∏–Ω</h2>
      <div class="small">EUR: <b id="shopEur">0</b> | Chips: <b id="shopChips">0</b></div>

      <div class="menu-buttons" style="margin-top:12px; grid-template-columns:1fr;">
        <button class="btn-accent" data-buy="1000">–ö—É–ø–∏—Ç—å 1 000 chips ‚Äî 10 EUR</button>
        <button class="btn-accent" data-buy="10000">–ö—É–ø–∏—Ç—å 10 000 chips ‚Äî 90 EUR</button>
        <button class="btn-accent" data-buy="100000">–ö—É–ø–∏—Ç—å 100 000 chips ‚Äî 390 EUR</button>
      </div>

      <div class="row" style="margin-top:10px; justify-content:space-between">
        <button id="btnShopBackMenu">‚ò∞ Menu</button>
        <button id="btnShopClose">Close</button>
      </div>
      <div class="small" style="margin-top:8px">
        –ü–æ–∫—É–ø–∫–∏ –¥–æ–±–∞–≤–ª—è—é—Ç —Ñ–∏—à–∫–∏ –≤ —Ç–≤–æ–π –∫–æ—à–µ–ª—ë–∫ (–æ–Ω–∏ –∂–µ —Å—Ç–∞—Ä—Ç–æ–≤—ã–π —Å—Ç–µ–∫ –≤ —Ç—É—Ä–Ω–∏—Ä–µ).
      </div>
    </div>
  </div>

  <!-- PLAY (mock lobby) -->
  <div class="overlay" id="playOverlay">
    <div class="cardbox">
      <h2>üéÆ –ò–≥—Ä–∞—Ç—å (–ª–æ–±–±–∏ –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞)</h2>
      <div class="small">
        –¢—É—Ç –ø–æ–∫–∞–∑–∞–Ω—ã 3 ‚Äú—Å—Ç–æ–ª–∞‚Äù –∏ ‚Äú–∏–≥—Ä–æ–∫–∏ –æ–Ω–ª–∞–π–Ω‚Äù (—Ä–∞–Ω–¥–æ–º). –î–ª—è –Ω–∞—Å—Ç–æ—è—â–µ–≥–æ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞ –Ω—É–∂–µ–Ω —Å–µ—Ä–≤–µ—Ä.
      </div>

      <div class="lobby" id="lobby"></div>

      <div class="row" style="margin-top:10px; justify-content:space-between">
        <button id="btnPlayBackMenu">‚ò∞ Menu</button>
        <button id="btnPlayClose">Close</button>
      </div>
    </div>
  </div>

<script>
/* =========================
   SETTINGS
========================= */
const START_CHIPS = 1000;
const SMALL_BLIND = 10;
const BIG_BLIND = 20;
const BOT_COUNT = 5;
const MAX_RAISES_PER_ROUND = 4;
const BOT_THINK_MS = 250;

const SHOP_PRICES = {
  1000: 10,
  10000: 90,
  100000: 390
};

const SUITS = ["‚ô£","‚ô¶","‚ô•","‚ô†"];
const RANKS = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
const RVAL = Object.fromEntries(RANKS.map((r,i)=>[r, i+2]));

/* =========================
   STATE (persistent per nick)
========================= */
let nick = null;
let saveKey = null;
let walletEUR = 0;
let walletChips = 0;

/* Tournament runtime */
let players = [];
let deck = [];
let board = [];
let pot = 0;
let stage = "IDLE";
let dealer = 0;
let sb = 1, bb = 2;
let current = 0;
let toCall = 0;
let raisesThisRound = 0;
let awaitingHuman = false;
let tournamentStarted = false;
let handInProgress = false;
let botTimer = null;

/* View state */
let view = "TOURNAMENT"; // TOURNAMENT / SHOP / PLAY

/* =========================
   UI refs
========================= */
const elTable = document.getElementById("table");
const elBoard = document.getElementById("board");
const elMsg = document.getElementById("msg");
const elLog = document.getElementById("log");

const hudNick = document.getElementById("hudNick");
const hudEur = document.getElementById("hudEur");
const hudChips = document.getElementById("hudChips");
const hudStage = document.getElementById("hudStage");
const hudPot = document.getElementById("hudPot");
const hudToCall = document.getElementById("hudToCall");
const hudDealer = document.getElementById("hudDealer");

const panelTitle = document.getElementById("panelTitle");
const raiseBox = document.getElementById("raiseBox");

const btnMenu = document.getElementById("btnMenu");
const btnStartResume = document.getElementById("btnStartResume");
const btnNextHand = document.getElementById("btnNextHand");
const btnFold = document.getElementById("btnFold");
const btnCall = document.getElementById("btnCall");
const btnRaise = document.getElementById("btnRaise");
const btnShopBig = document.getElementById("btnShopBig");

const raiseSlider = document.getElementById("raiseSlider");
const raiseToLabel = document.getElementById("raiseToLabel");
const raiseMinEl = document.getElementById("raiseMin");
const raiseMaxEl = document.getElementById("raiseMax");

const menuOverlay = document.getElementById("menuOverlay");
const nickOverlay = document.getElementById("nickOverlay");
const shopOverlay = document.getElementById("shopOverlay");
const playOverlay = document.getElementById("playOverlay");

const nickInput = document.getElementById("nickInput");
const nickOk = document.getElementById("nickOk");

const btnGoPlay = document.getElementById("btnGoPlay");
const btnGoShop = document.getElementById("btnGoShop");
const btnGoTournament = document.getElementById("btnGoTournament");
const btnCloseMenu = document.getElementById("btnCloseMenu");

const shopEur = document.getElementById("shopEur");
const shopChips = document.getElementById("shopChips");
const btnShopClose = document.getElementById("btnShopClose");
const btnShopBackMenu = document.getElementById("btnShopBackMenu");

const lobby = document.getElementById("lobby");
const btnPlayClose = document.getElementById("btnPlayClose");
const btnPlayBackMenu = document.getElementById("btnPlayBackMenu");

/* =========================
   Persistence
========================= */
function keyForNick(n){ return `poker_v2_${n.toLowerCase()}`; }

function saveAll(){
  if(!saveKey) return;
  const state = {
    version: 2,
    nick,
    walletEUR,
    walletChips,
    tournament: {
      players, deck, board, pot, stage, dealer, sb, bb, current,
      toCall, raisesThisRound, tournamentStarted, handInProgress
    },
    log: elLog.textContent.slice(0, 6000)
  };
  localStorage.setItem(saveKey, JSON.stringify(state));
  localStorage.setItem("poker_last_nick", nick);
}

function loadAll(n){
  const k = keyForNick(n);
  const raw = localStorage.getItem(k);
  if(!raw) return null;
  try { return JSON.parse(raw); } catch { return null; }
}

function ensureProfile(){
  const st = loadAll(nick);
  if(!st){
    walletEUR = 0;
    walletChips = START_CHIPS;
    clearTournamentState();
    tournamentStarted = false;
    handInProgress = false;
    stage = "IDLE";
    elLog.textContent = "";
    logLine("New profile created.");
    saveAll();
  } else {
    walletEUR = Number(st.walletEUR ?? 0);
    walletChips = Number(st.walletChips ?? START_CHIPS);
    elLog.textContent = st.log ?? "";

    const t = st.tournament;
    if(t && t.players && t.players.length){
      players = t.players;
      deck = t.deck ?? [];
      board = t.board ?? [];
      pot = t.pot ?? 0;
      stage = t.stage ?? "IDLE";
      dealer = t.dealer ?? 0;
      sb = t.sb ?? 1;
      bb = t.bb ?? 2;
      current = t.current ?? 0;
      toCall = t.toCall ?? 0;
      raisesThisRound = t.raisesThisRound ?? 0;
      tournamentStarted = !!t.tournamentStarted;
      handInProgress = !!t.handInProgress;

      // make sure YOU name matches current nick
      if(players[0] && !players[0].isBot) players[0].name = nick;
    } else {
      clearTournamentState();
    }
  }
}

/* =========================
   Helpers
========================= */
function logLine(s){
  elLog.textContent = (s + "\n" + elLog.textContent).slice(0, 6000);
}
function chipFly(text){
  const el = document.createElement("div");
  el.className = "chip-fly";
  el.textContent = text;
  elTable.appendChild(el);
  setTimeout(()=>el.remove(), 750);
}
function newDeck(){
  const d = [];
  for(const s of SUITS) for(const r of RANKS) d.push({r,s});
  for(let i=d.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}
function inHandPlayers(){ return players.filter(p => !p.out && !p.folded); }
function nextActiveIndex(from){
  const n = players.length;
  for(let k=1;k<=n;k++){
    const i = (from + k) % n;
    if(!players[i].out && !players[i].folded) return i;
  }
  return from;
}
function nextNotOutIndex(from){
  const n = players.length;
  for(let k=1;k<=n;k++){
    const i = (from + k) % n;
    if(!players[i].out) return i;
  }
  return from;
}
function onlyOneLeftInHand(){ return inHandPlayers().length === 1; }
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

/* =========================
   EVALUATOR
========================= */
function straightHigh(uniqueRanksDesc){
  const set = new Set(uniqueRanksDesc);
  if(set.has(14) && set.has(5) && set.has(4) && set.has(3) && set.has(2)) return 5;
  for(let hi=14;hi>=5;hi--){
    let ok=true;
    for(let d=0;d<5;d++){
      if(!set.has(hi-d)){ ok=false; break; }
    }
    if(ok) return hi;
  }
  return 0;
}
function evaluate7(cards){
  const ranks = cards.map(c=>RVAL[c.r]).sort((a,b)=>b-a);
  const suitMap = new Map();
  const countMap = new Map();
  for(const c of cards){
    suitMap.set(c.s, (suitMap.get(c.s)||0)+1);
    const v = RVAL[c.r];
    countMap.set(v, (countMap.get(v)||0)+1);
  }
  const unique = [...new Set(ranks)].sort((a,b)=>b-a);

  let flushSuit = null;
  for(const [s,c] of suitMap.entries()){
    if(c>=5){ flushSuit = s; break; }
  }
  let flushRanks = null;
  if(flushSuit){
    flushRanks = cards.filter(c=>c.s===flushSuit).map(c=>RVAL[c.r]).sort((a,b)=>b-a);
  }
  if(flushRanks){
    const uniqFlush = [...new Set(flushRanks)].sort((a,b)=>b-a);
    const sf = straightHigh(uniqFlush);
    if(sf) return { cat: 8, tiebreak: [sf] };
  }

  const groups = [...countMap.entries()].map(([r,c])=>({r,c}))
    .sort((a,b)=>(b.c-a.c)||(b.r-a.r));
  const fours = groups.filter(g=>g.c===4).map(g=>g.r);
  const threes = groups.filter(g=>g.c===3).map(g=>g.r);
  const pairs  = groups.filter(g=>g.c===2).map(g=>g.r);

  if(fours.length){
    const quad = Math.max(...fours);
    const kicker = unique.find(r=>r!==quad);
    return { cat: 7, tiebreak: [quad, kicker] };
  }
  if(threes.length){
    const trip = Math.max(...threes);
    const remainingTrips = threes.filter(r=>r!==trip);
    const bestPair = pairs.length ? Math.max(...pairs) : (remainingTrips.length ? Math.max(...remainingTrips) : 0);
    if(bestPair) return { cat: 6, tiebreak: [trip, bestPair] };
  }
  if(flushRanks) return { cat: 5, tiebreak: flushRanks.slice(0,5) };
  const st = straightHigh(unique);
  if(st) return { cat: 4, tiebreak: [st] };
  if(threes.length){
    const trip = Math.max(...threes);
    const kickers = unique.filter(r=>r!==trip).slice(0,2);
    return { cat: 3, tiebreak: [trip, ...kickers] };
  }
  if(pairs.length >= 2){
    const sortedPairs = [...pairs].sort((a,b)=>b-a);
    const p1 = sortedPairs[0], p2 = sortedPairs[1];
    const kicker = unique.find(r=>r!==p1 && r!==p2);
    return { cat: 2, tiebreak: [p1, p2, kicker] };
  }
  if(pairs.length === 1){
    const p = pairs[0];
    const kickers = unique.filter(r=>r!==p).slice(0,3);
    return { cat: 1, tiebreak: [p, ...kickers] };
  }
  return { cat: 0, tiebreak: unique.slice(0,5) };
}
function compareEval(a,b){
  if(a.cat !== b.cat) return a.cat - b.cat;
  for(let i=0;i<Math.max(a.tiebreak.length,b.tiebreak.length);i++){
    const x=a.tiebreak[i]||0, y=b.tiebreak[i]||0;
    if(x!==y) return x-y;
  }
  return 0;
}
function catName(cat){
  return ["High","Pair","Two Pair","Trips","Straight","Flush","Full House","Quads","Straight Flush"][cat] || "Unknown";
}

/* =========================
   Tournament core
========================= */
function clearTournamentState(){
  players = [];
  deck = [];
  board = [];
  pot = 0;
  stage = "IDLE";
  dealer = 0; sb = 1; bb = 2;
  current = 0; toCall = 0; raisesThisRound = 0;
  awaitingHuman = false;
  tournamentStarted = false;
  handInProgress = false;
}

function createTournament(){
  players = [];
  players.push({name:nick, isBot:false, chips:walletChips, bet:0, folded:false, out:false, hand:[]});
  for(let i=1;i<=BOT_COUNT;i++){
    players.push({name:`BOT${i}`, isBot:true, chips:walletChips, bet:0, folded:false, out:false, hand:[]});
  }
  dealer = 0; sb = 1; bb = 2;
  stage = "IDLE";
  pot = 0;
  board = [];
  toCall = 0;
  raisesThisRound = 0;
  awaitingHuman = false;
  tournamentStarted = true;
  handInProgress = false;
  logLine("Tournament created.");
  elMsg.textContent = "–ù–∞–∂–º–∏ Next Hand.";
  saveAll();
  render();
  tick();
}

function cleanupEliminations(){
  for(const p of players){
    if(!p.out && p.chips <= 0){
      p.out = true;
      p.chips = 0;
      logLine(`${p.name} is OUT!`);
    }
  }
}

function checkTournamentWinner(){
  const alive = players.filter(p=>!p.out);
  if(alive.length === 1){
    const winner = alive[0];
    elMsg.textContent = `üèÜ CHAMPION: ${winner.name}! +10 EUR`;
    logLine(`üèÜ TOURNAMENT WINNER: ${winner.name}`);

    // EUR reward ONLY when tournament ends
    if(winner.name === nick){
      walletEUR += 10;
      logLine(`+10 EUR (total: ${walletEUR})`);
      chipFly("+10 EUR");
    }

    handInProgress = false;
    stage = "IDLE";
    awaitingHuman = false;
    saveAll();
    renderHUD();
  }
}

function resetRoundBets(){
  for(const p of players) p.bet = 0;
  toCall = 0;
  raisesThisRound = 0;
}
function postBlind(i, amount){
  const p = players[i];
  const pay = Math.min(amount, p.chips);
  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  if(pay>0) chipFly(`-${pay}`);
}

function bettingRoundComplete(){
  const ps = inHandPlayers();
  for(const p of ps){
    if(p.chips === 0) continue;
    if(p.bet !== toCall) return false;
  }
  return true;
}
function minRaiseTo(){ return toCall + BIG_BLIND; }

function startHand(){
  if(!tournamentStarted) return;
  cleanupEliminations();
  checkTournamentWinner();
  if(players.filter(p=>!p.out).length < 2) return;

  handInProgress = true;
  deck = newDeck();
  board = [];
  pot = 0;
  for(const p of players){
    p.folded = false; p.bet = 0; p.hand = [];
  }

  dealer = nextNotOutIndex(dealer);
  sb = nextNotOutIndex(dealer);
  bb = nextNotOutIndex(sb);

  // deal
  for(let r=0;r<2;r++){
    for(const p of players) if(!p.out) p.hand.push(deck.pop());
  }

  resetRoundBets();
  postBlind(sb, SMALL_BLIND);
  postBlind(bb, BIG_BLIND);
  toCall = Math.max(players[sb].bet, players[bb].bet);

  stage = "PREFLOP";
  current = nextActiveIndex(bb);
  awaitingHuman = false;

  logLine(`--- New hand --- Dealer:${players[dealer].name} SB:${players[sb].name} BB:${players[bb].name}`);
  elMsg.textContent = "–†–∞–∑–¥–∞—á–∞ –Ω–∞—á–∞–ª–∞—Å—å.";
  saveAll();
  render();
  tick();
}

function advanceStage(){
  for(const p of players) p.bet = 0;
  toCall = 0;
  raisesThisRound = 0;

  if(stage==="PREFLOP"){
    board.push(deck.pop(), deck.pop(), deck.pop());
    stage="FLOP";
  } else if(stage==="FLOP"){
    board.push(deck.pop());
    stage="TURN";
  } else if(stage==="TURN"){
    board.push(deck.pop());
    stage="RIVER";
  } else if(stage==="RIVER"){
    stage="SHOWDOWN";
  }

  current = nextActiveIndex(dealer);
  awaitingHuman = false;

  if(stage==="SHOWDOWN") return doShowdown();

  logLine(`Stage: ${stage}`);
  saveAll();
  render();
  tick();
}

function doShowdown(){
  const contenders = inHandPlayers();
  if(contenders.length === 1) return awardPotTo(players.indexOf(contenders[0]), "(everyone folded)");

  const evals = contenders.map(p=>({p, e:evaluate7([...p.hand, ...board])}));
  evals.sort((a,b)=>compareEval(a.e,b.e));
  const best = evals[evals.length-1].e;
  const winners = evals.filter(x=>compareEval(x.e,best)===0).map(x=>x.p);

  logLine(`Showdown: best=${catName(best.cat)} winners=${winners.map(w=>w.name).join(", ")}`);

  const share = Math.floor(pot / winners.length);
  let rem = pot - share*winners.length;
  for(const w of winners){
    w.chips += share;
    if(rem>0){ w.chips += 1; rem--; }
  }
  chipFly(`+${pot}`);
  pot = 0;

  handInProgress = false;
  stage = "IDLE";
  awaitingHuman = false;
  cleanupEliminations();
  checkTournamentWinner();
  saveAll();
  render();
  tick();
}

function awardPotTo(idx, reason){
  players[idx].chips += pot;
  chipFly(`+${pot}`);
  logLine(`${players[idx].name} wins ${pot} ${reason||""}`.trim());
  pot = 0;

  handInProgress = false;
  stage = "IDLE";
  awaitingHuman = false;

  cleanupEliminations();
  checkTournamentWinner();
  saveAll();
  render();
  tick();
}

function playerFold(i){
  players[i].folded = true;
  logLine(`${players[i].name} folds`);
  saveAll();
  render();
  if(onlyOneLeftInHand()){
    return awardPotTo(players.indexOf(inHandPlayers()[0]), "(everyone folded)");
  }
  current = nextActiveIndex(i);
  tick();
}

function playerCall(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  const pay = Math.min(need, p.chips);
  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  if(pay>0) chipFly(`-${pay}`);
  logLine(`${p.name} ${need===0?"checks":"calls"} ${pay}`);
  saveAll();
  render();

  current = nextActiveIndex(i);
  if(bettingRoundComplete()) return advanceStage();
  tick();
}

function playerRaiseTo(i, raiseTo){
  if(raisesThisRound >= MAX_RAISES_PER_ROUND) return playerCall(i);

  const p = players[i];
  raiseTo = Math.max(raiseTo, minRaiseTo());
  raiseTo = Math.min(raiseTo, p.bet + p.chips); // all-in cap

  const add = Math.max(0, raiseTo - p.bet);
  const pay = Math.min(add, p.chips);
  if(pay<=0) return playerCall(i);

  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  toCall = Math.max(toCall, p.bet);
  raisesThisRound++;
  chipFly(`-${pay}`);
  logLine(`${p.name} raises to ${p.bet}`);
  saveAll();
  render();

  current = nextActiveIndex(i);
  tick();
}

/* =========================
   Smarter bots (simple)
========================= */
function botDecision(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  const stack = Math.max(1, p.chips);
  const potOdds = need / Math.max(1, pot + need);
  const pressure = need / (stack + 1);

  if(stage==="PREFLOP"){
    const a = RVAL[p.hand[0].r], b = RVAL[p.hand[1].r];
    const pair = p.hand[0].r === p.hand[1].r;
    const suited = p.hand[0].s === p.hand[1].s;
    const gap = Math.abs(a-b);
    const high = Math.max(a,b);

    let score = 0.0;
    score += pair ? 0.55 : 0.0;
    score += (high/14)*0.30;
    score += suited ? 0.08 : 0.0;
    score += (gap<=2) ? 0.06 : 0.0;
    score += (high>=12) ? 0.06 : 0.0;
    score += (Math.random()-0.5)*0.06;

    if(need===0){
      if(score>0.72 && p.chips > BIG_BLIND*2 && Math.random()<0.35) return "RAISE";
      return "CALL";
    }
    if(score < 0.33 && (pressure>0.12 || potOdds>0.28) && Math.random()<0.80) return "FOLD";
    if(score > 0.74 && p.chips > need + BIG_BLIND && Math.random()<0.50) return "RAISE";
    return "CALL";
  }

  const e = evaluate7([...p.hand, ...board]);
  let strength = (e.cat/8) + (Math.random()-0.5)*0.08;

  if(need===0){
    if(strength > 0.62 && raisesThisRound < MAX_RAISES_PER_ROUND && Math.random()<0.30) return "RAISE";
    return "CALL";
  }
  if(strength < 0.25 && (pressure>0.14 || potOdds>0.30) && Math.random()<0.80) return "FOLD";
  if(strength > 0.70 && raisesThisRound < MAX_RAISES_PER_ROUND && Math.random()<0.40) return "RAISE";
  if(potOdds < 0.34) return "CALL";
  if(Math.random()<0.15) return "FOLD";
  return "CALL";
}

function botAct(){
  if(!handInProgress) return;
  if(players[current].out || players[current].folded) current = nextActiveIndex(current);

  if(onlyOneLeftInHand()) return awardPotTo(players.indexOf(inHandPlayers()[0]), "(everyone folded)");

  const d = botDecision(current);
  if(d==="FOLD") playerFold(current);
  else if(d==="RAISE"){
    const p = players[current];
    const min = minRaiseTo();
    const maxTo = p.bet + p.chips;
    let target = min + Math.floor(Math.random()*3)*BIG_BLIND;
    const e = (stage!=="PREFLOP") ? evaluate7([...p.hand,...board]) : null;
    if(e && e.cat>=4) target += BIG_BLIND*3;
    if(e && e.cat>=6) target += BIG_BLIND*5;
    target = clamp(target, min, maxTo);
    playerRaiseTo(current, target);
  } else {
    playerCall(current);
  }
}

/* =========================
   Tick manager
========================= */
function tick(){
  clearTimeout(botTimer);

  if(view !== "TOURNAMENT"){
    updateButtons();
    updateRaiseUI();
    return;
  }

  cleanupEliminations();
  checkTournamentWinner();

  if(!handInProgress || stage==="IDLE" || stage==="SHOWDOWN"){
    awaitingHuman = false;
    updateButtons();
    updateRaiseUI();
    return;
  }

  if(players[current].out || players[current].folded){
    current = nextActiveIndex(current);
  }

  if(!players[current].isBot){
    awaitingHuman = true;
    elMsg.textContent = "–¢–≤–æ–π —Ö–æ–¥: Fold / Call-Check / Raise";
    updateButtons();
    updateRaiseUI();
    return;
  }

  awaitingHuman = false;
  elMsg.textContent = "–ë–æ—Ç –¥—É–º–∞–µ—Ç‚Ä¶";
  updateButtons();
  updateRaiseUI();

  botTimer = setTimeout(()=>botAct(), BOT_THINK_MS);
}

/* =========================
   Render
========================= */
function makeCardEl(text, hidden, animate){
  const el = document.createElement("div");
  el.className = "card" + (hidden ? " hidden" : "") + (animate ? " deal" : "");
  if(hidden){
    el.textContent = "üÇ†";
    return el;
  }
  if(!text){
    el.style.opacity = "0.35";
    el.textContent = "‚Äî";
    return el;
  }
  const r = text.slice(0,1);
  const s = text.slice(1);
  const small = document.createElement("small");
  small.textContent = r;
  const suit = document.createElement("div");
  suit.className = "suit";
  suit.textContent = s;
  el.appendChild(small);
  el.appendChild(suit);
  return el;
}

function renderHUD(){
  hudNick.textContent = nick ?? "-";
  hudEur.textContent = String(walletEUR);
  hudChips.textContent = String(walletChips);
  hudStage.textContent = stage;
  hudPot.textContent = String(pot);
  hudToCall.textContent = String(toCall);
  hudDealer.textContent = (tournamentStarted && players[dealer]) ? players[dealer].name : "-";
}

function render(){
  // remove old seats
  [...elTable.querySelectorAll(".seat")].forEach(n=>n.remove());

  // board
  elBoard.innerHTML = "";
  for(let i=0;i<5;i++){
    const c = board[i];
    elBoard.appendChild(makeCardEl(c ? (c.r+c.s) : "", !c, !!c));
  }

  renderHUD();

  // seats positions
  const seatPos = ["pos-0","pos-1","pos-2","pos-3","pos-4","pos-5"];
  for(let i=0;i<players.length;i++){
    const p = players[i];

    const seat = document.createElement("div");
    seat.className = `seat ${seatPos[i]||"pos-5"}`;

    const top = document.createElement("div");
    top.className = "top";
    const nm = document.createElement("div");
    nm.className = "name";
    nm.textContent = p.name;

    const tag = document.createElement("div");
    tag.className = "tag";
    if(p.out){ tag.classList.add("out"); tag.textContent = "OUT"; }
    else if(handInProgress && i===current && !p.folded){ tag.classList.add("turn"); tag.textContent = "TURN"; }
    else tag.textContent = p.isBot ? "BOT" : "YOU";

    top.appendChild(nm);
    top.appendChild(tag);

    const meta = document.createElement("div");
    meta.className = "meta";
    meta.innerHTML = `<span>chips: <b>${p.chips}</b></span><span>${p.folded ? "<span style='color:var(--danger)'>folded</span>" : ""}</span>`;

    const cards = document.createElement("div");
    cards.className = "cards" + ((i===0 && p.folded) ? " folded" : "");

    const hidden = p.isBot && handInProgress && stage!=="SHOWDOWN";
    const show = !p.isBot || stage==="SHOWDOWN" || !handInProgress;
    const c1 = p.hand?.[0], c2 = p.hand?.[1];

    cards.appendChild(makeCardEl(c1 ? (c1.r+c1.s) : "", hidden || !show, !!c1));
    cards.appendChild(makeCardEl(c2 ? (c2.r+c2.s) : "", hidden || !show, !!c2));

    const bet = document.createElement("div");
    bet.className = "bet";
    bet.textContent = p.out ? "" : (p.bet>0 ? `Bet: ${p.bet}` : "");

    seat.appendChild(top);
    seat.appendChild(meta);
    seat.appendChild(cards);
    seat.appendChild(bet);

    elTable.appendChild(seat);
  }

  updateRaiseUI();
  updateButtons();
}

function updateRaiseUI(){
  if(view !== "TOURNAMENT" || !handInProgress || !players[0] || players[0].out){
    raiseSlider.min = 0; raiseSlider.max = 0; raiseSlider.value = 0;
    raiseToLabel.textContent = "0";
    raiseMinEl.textContent = "0";
    raiseMaxEl.textContent = "0";
    return;
  }
  const you = players[0];
  const minTo = clamp(minRaiseTo(), 0, you.bet + you.chips);
  const maxTo = you.bet + you.chips;

  raiseSlider.min = minTo;
  raiseSlider.max = maxTo;
  if(Number(raiseSlider.value) < minTo) raiseSlider.value = minTo;
  if(Number(raiseSlider.value) > maxTo) raiseSlider.value = maxTo;

  raiseToLabel.textContent = String(raiseSlider.value);
  raiseMinEl.textContent = String(minTo);
  raiseMaxEl.textContent = String(maxTo);
}

function updateButtons(){
  const inTournament = (view === "TOURNAMENT");
  panelTitle.textContent = inTournament ? "Tournament" : (view==="SHOP" ? "Shop" : "Play");
  raiseBox.style.display = inTournament ? "block" : "none";

  btnStartResume.disabled = !nick;
  btnNextHand.disabled = !(inTournament && tournamentStarted && !handInProgress && players.filter(p=>!p.out).length>=2);
  const yourTurn = inTournament && tournamentStarted && handInProgress && awaitingHuman && current===0 && !players[0].folded && !players[0].out;

  btnFold.disabled = !yourTurn;
  btnCall.disabled = !yourTurn;
  btnRaise.disabled = !yourTurn || raisesThisRound >= MAX_RAISES_PER_ROUND;
}

/* =========================
   Views
========================= */
function showOverlay(el, yes){ el.style.display = yes ? "flex" : "none"; }

function openMenu(){
  showOverlay(menuOverlay, true);
}
function closeMenu(){
  showOverlay(menuOverlay, false);
}
function openShop(){
  view = "SHOP";
  shopEur.textContent = String(walletEUR);
  shopChips.textContent = String(walletChips);
  showOverlay(shopOverlay, true);
  showOverlay(playOverlay, false);
  closeMenu();
  updateButtons();
}
function closeShop(){
  showOverlay(shopOverlay, false);
  if(view==="SHOP") view="TOURNAMENT";
  updateButtons();
  tick();
}
function openPlay(){
  view = "PLAY";
  buildLobby();
  showOverlay(playOverlay, true);
  showOverlay(shopOverlay, false);
  closeMenu();
  updateButtons();
}
function closePlay(){
  showOverlay(playOverlay, false);
  if(view==="PLAY") view="TOURNAMENT";
  updateButtons();
  tick();
}
function goTournament(){
  view = "TOURNAMENT";
  showOverlay(shopOverlay, false);
  showOverlay(playOverlay, false);
  closeMenu();
  updateButtons();
  tick();
}

/* =========================
   Lobby (mock online)
========================= */
function randomNick(){
  const a = ["neo","max","viper","fox","jazz","storm","ace","byte","wolf","kira","mike","zero","rex","iris","nova"];
  const b = Math.floor(Math.random()*900)+100;
  return a[Math.floor(Math.random()*a.length)] + b;
}
function buildLobby(){
  lobby.innerHTML = "";
  const tables = [
    {id:1, name:"Table #1", seats:6},
    {id:2, name:"Table #2", seats:6},
    {id:3, name:"Table #3", seats:6},
  ];
  for(const t of tables){
    const box = document.createElement("div");
    box.className = "tbl";
    const head = document.createElement("div");
    head.className = "tbl-head";
    head.innerHTML = `<b>${t.name}</b><span class="pill">Players online: <b>${Math.floor(Math.random()*6)+1}</b></span>`;
    const seats = document.createElement("div");
    seats.className = "seats-mini";

    // your seat + random
    const youSeat = document.createElement("span");
    youSeat.className = "seat-mini you";
    youSeat.textContent = nick ? `${nick} (you)` : "you";
    seats.appendChild(youSeat);

    const count = Math.floor(Math.random()*5)+1;
    for(let i=0;i<count;i++){
      const s = document.createElement("span");
      s.className = "seat-mini";
      s.textContent = randomNick();
      seats.appendChild(s);
    }

    const actions = document.createElement("div");
    actions.className = "row";
    actions.style.marginTop = "10px";
    const join = document.createElement("button");
    join.className = "btn-accent";
    join.textContent = "Join (demo)";
    join.onclick = ()=> alert("–≠—Ç–æ –¥–µ–º–æ –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞. –î–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –æ–Ω–ª–∞–π–Ω–∞ –Ω—É–∂–µ–Ω –±—ç–∫–µ–Ω–¥.");
    actions.appendChild(join);

    box.appendChild(head);
    box.appendChild(seats);
    box.appendChild(actions);
    lobby.appendChild(box);
  }
}

/* =========================
   Events
========================= */
btnMenu.addEventListener("click", openMenu);
btnCloseMenu.addEventListener("click", closeMenu);

btnGoShop.addEventListener("click", openShop);
btnGoPlay.addEventListener("click", openPlay);
btnGoTournament.addEventListener("click", goTournament);

btnShopBackMenu.addEventListener("click", ()=>{ closeShop(); openMenu(); });
btnShopClose.addEventListener("click", closeShop);

btnPlayBackMenu.addEventListener("click", ()=>{ closePlay(); openMenu(); });
btnPlayClose.addEventListener("click", closePlay);

btnShopBig.addEventListener("click", openShop);

btnStartResume.addEventListener("click", ()=>{
  if(!nick) return;
  if(!tournamentStarted){
    createTournament();
  } else {
    // resume just keeps state and continues
    render();
    tick();
  }
});

btnNextHand.addEventListener("click", startHand);

btnFold.addEventListener("click", ()=>{
  if(view==="TOURNAMENT" && awaitingHuman && current===0){ awaitingHuman=false; playerFold(0); }
});
btnCall.addEventListener("click", ()=>{
  if(view==="TOURNAMENT" && awaitingHuman && current===0){ awaitingHuman=false; playerCall(0); }
});
btnRaise.addEventListener("click", ()=>{
  if(view==="TOURNAMENT" && awaitingHuman && current===0){
    awaitingHuman=false;
    playerRaiseTo(0, Number(raiseSlider.value));
  }
});
raiseSlider.addEventListener("input", ()=> raiseToLabel.textContent = String(raiseSlider.value));

shopOverlay.querySelectorAll("[data-buy]").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const chips = Number(btn.getAttribute("data-buy"));
    const price = SHOP_PRICES[chips];
    if(walletEUR < price){
      alert(`–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç EUR. –ù—É–∂–Ω–æ ${price}, —É —Ç–µ–±—è ${walletEUR}.`);
      return;
    }
    walletEUR -= price;
    walletChips += chips;
    logLine(`Shop: bought ${chips} chips for ${price} EUR`);
    chipFly(`-${price} EUR`);
    shopEur.textContent = String(walletEUR);
    shopChips.textContent = String(walletChips);
    renderHUD();
    saveAll();
  });
});

/* =========================
   Nick flow (ask immediately)
========================= */
function openNick(){
  showOverlay(nickOverlay, true);
  nickInput.value = "";
  setTimeout(()=>nickInput.focus(), 50);
}
function closeNick(){
  showOverlay(nickOverlay, false);
}

nickOk.addEventListener("click", ()=>{
  const n = nickInput.value.trim();
  if(!n) { nickInput.focus(); return; }
  nick = n;
  saveKey = keyForNick(nick);
  ensureProfile();
  closeNick();
  render();
  tick();
  openMenu(); // after nick -> show menu
});

nickInput.addEventListener("keydown", (e)=>{
  if(e.key==="Enter") nickOk.click();
});

/* =========================
   Boot
========================= */
function boot(){
  // Ask nick immediately (requirement)
  const last = localStorage.getItem("poker_last_nick");
  if(last){
    // still ask immediately, but prefill
    openNick();
    nickInput.value = last;
    nickInput.select();
  } else {
    openNick();
  }

  elMsg.textContent = "";
  renderHUD();
  render();
  updateButtons();
}
boot();
</script>
</body>
</html>
