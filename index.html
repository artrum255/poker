<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Poker Tournament (YOU vs Bots)</title>
<style>
  :root{
    --bg:#0f2e1f;
    --felt:#146b3a;
    --felt2:#0f5a30;
    --panel:#0b0f12cc;
    --text:#e9f2ec;
    --muted:#b9c9bf;
    --accent:#66ffb3;
    --danger:#ff6b6b;
    --warn:#ffd166;
    --card:#f6f7fb;
    --cardText:#101316;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    background:radial-gradient(1200px 700px at 50% 35%, #174a33, #08150f);
    color:var(--text);
  }
  .wrap{
    max-width:1100px;
    margin:0 auto;
    padding:16px;
    display:grid;
    gap:12px;
    grid-template-columns: 1fr 320px;
  }
  @media (max-width: 980px){
    .wrap{grid-template-columns:1fr}
  }

  /* Table */
  .table{
    position:relative;
    height:620px;
    border-radius:24px;
    background:
      radial-gradient(120% 100% at 50% 40%, var(--felt), var(--felt2));
    box-shadow: 0 18px 60px #00000066;
    overflow:hidden;
    border:1px solid #ffffff1a;
  }
  .table::before{
    content:"";
    position:absolute; inset:22px;
    border-radius:999px;
    border:2px solid #ffffff1c;
  }
  .center{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:min(560px, 92%);
    text-align:center;
  }
  .board{
    display:flex;
    gap:8px;
    justify-content:center;
    flex-wrap:wrap;
    margin:10px 0 6px;
  }
  .chipline{
    display:flex;
    justify-content:center;
    gap:18px;
    flex-wrap:wrap;
    color:var(--muted);
    font-size:14px;
  }
  .pill{
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding:6px 10px;
    border-radius:999px;
    background:#0000002a;
    border:1px solid #ffffff12;
  }
  .msg{
    margin-top:10px;
    font-size:14px;
    color:var(--text);
    opacity:.95;
  }

  /* Seats */
  .seat{
    position:absolute;
    width:220px;
    padding:10px;
    border-radius:16px;
    background: linear-gradient(180deg, #0b0f12cc, #0b0f1299);
    border:1px solid #ffffff14;
    box-shadow: 0 10px 30px #00000055;
    backdrop-filter: blur(6px);
  }
  .seat .top{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom:8px;
  }
  .name{
    font-weight:700;
    letter-spacing:.2px;
  }
  .tag{
    font-size:12px;
    color:var(--muted);
    border:1px solid #ffffff18;
    padding:2px 8px;
    border-radius:999px;
  }
  .tag.turn{ color:var(--accent); border-color:#66ffb340; }
  .tag.out{ color:var(--danger); border-color:#ff6b6b55; }
  .meta{
    display:flex;
    justify-content:space-between;
    font-size:13px;
    color:var(--muted);
    margin-bottom:8px;
  }
  .cards{
    display:flex;
    gap:8px;
  }
  .card{
    width:56px;
    height:76px;
    border-radius:10px;
    background: var(--card);
    color:var(--cardText);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    letter-spacing:.4px;
    box-shadow: 0 8px 18px #00000055;
    position:relative;
    border:1px solid #00000022;
  }
  .card.hidden{
    background: linear-gradient(135deg, #1b2a3a, #0e1722);
    color:#ffffffaa;
    border-color:#ffffff1a;
  }
  .card small{
    position:absolute;
    left:8px; top:6px;
    font-size:12px;
    font-weight:900;
    opacity:.9;
  }
  .card .suit{
    font-size:22px;
  }
  .bet{
    margin-top:8px;
    font-size:13px;
    color:var(--warn);
  }

  /* Seat positions (up to 6) */
  .pos-0{ left:50%; bottom:14px; transform:translateX(-50%); } /* YOU */
  .pos-1{ left:18px; bottom:140px; }
  .pos-2{ left:18px; top:90px; }
  .pos-3{ left:50%; top:14px; transform:translateX(-50%); }
  .pos-4{ right:18px; top:90px; }
  .pos-5{ right:18px; bottom:140px; }

  /* Side panel */
  .panel{
    padding:14px;
    border-radius:18px;
    background: linear-gradient(180deg, #0b0f12cc, #0b0f1299);
    border:1px solid #ffffff14;
    box-shadow: 0 10px 30px #00000055;
    backdrop-filter: blur(6px);
    height:620px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .panel h3{
    margin:0;
    font-size:18px;
  }
  .controls{
    display:grid;
    gap:8px;
    margin-top:6px;
  }
  button{
    padding:10px 12px;
    border-radius:12px;
    border:1px solid #ffffff18;
    background:#0b0f12;
    color:var(--text);
    font-weight:700;
    cursor:pointer;
  }
  button:hover{ border-color:#ffffff35; }
  button:disabled{
    opacity:.45;
    cursor:not-allowed;
  }
  .btn-accent{
    background: linear-gradient(180deg, #1a3b2b, #0b1f16);
    border-color:#66ffb333;
  }
  .small{
    font-size:13px;
    color:var(--muted);
    line-height:1.35;
  }
  .log{
    flex:1;
    overflow:auto;
    padding:10px;
    border-radius:14px;
    background:#00000022;
    border:1px solid #ffffff12;
    font-size:13px;
    color:var(--muted);
    white-space:pre-wrap;
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="table" id="table">
      <div class="center">
        <div class="chipline">
          <span class="pill">üÉè <span id="stage">IDLE</span></span>
          <span class="pill">üí∞ Pot: <b id="pot">0</b></span>
          <span class="pill">üìû To call: <b id="tocall">0</b></span>
          <span class="pill">üü¢ Dealer: <b id="dealer">-</b></span>
        </div>

        <div class="board" id="board"></div>

        <div class="msg" id="msg">–ù–∞–∂–º–∏ ‚ÄúStart Tournament‚Äù</div>
      </div>
    </div>

    <div class="panel">
      <h3>Controls</h3>
      <div class="controls">
        <button class="btn-accent" id="btnStart">Start Tournament</button>
        <button id="btnNextHand">Next Hand</button>
        <button id="btnFold">Fold</button>
        <button id="btnCall">Call / Check</button>
        <button id="btnRaise">Raise</button>
      </div>

      <div class="small">
        <b>–ü—Ä–∞–≤–∏–ª–∞:</b> Texas Hold‚Äôem. –†–µ–∞–ª—å–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏. –ë–æ—Ç—ã –∏–≥—Ä–∞—é—Ç –ø—Ä–æ—Å—Ç–æ, –Ω–æ —á–µ—Å—Ç–Ω–æ.<br>
        <b>–í—ã–ª–µ—Ç:</b> –µ—Å–ª–∏ —Ñ–∏—à–∫–∏ = 0 ‚Üí OUT. –ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è –ø–æ–∫–∞ –Ω–µ –æ—Å—Ç–∞–Ω–µ—Ç—Å—è 1 –ø–æ–±–µ–¥–∏—Ç–µ–ª—å.<br><br>
        <b>Raise:</b> —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä (–±—ã—Å—Ç—Ä–æ –∏ –±–µ–∑ –∑–∞–º–æ—Ä–æ—á–µ–∫).
      </div>

      <div class="log" id="log"></div>
    </div>
  </div>

<script>
/* =========================
   SETTINGS
========================= */
const START_CHIPS = 200;
const SMALL_BLIND = 2;
const BIG_BLIND = 4;
const BOT_COUNT = 5;           // + YOU = 6 –º–µ—Å—Ç –º–∞–∫—Å–∏–º—É–º
const MAX_RAISES_PER_ROUND = 3; // —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã—Ö —Ä–µ–π–∑–æ–≤
const SUITS = ["‚ô£","‚ô¶","‚ô•","‚ô†"];
const RANKS = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
const RVAL = Object.fromEntries(RANKS.map((r,i)=>[r, i+2]));

/* =========================
   STATE
========================= */
let players = [];
let deck = [];
let board = [];
let pot = 0;
let stage = "IDLE"; // PREFLOP/FLOP/TURN/RIVER/SHOWDOWN/IDLE
let dealer = 0;
let sb = 1, bb = 2;
let current = 0;
let toCall = 0;
let raisesThisRound = 0;
let awaitingHuman = false;
let tournamentStarted = false;
let handInProgress = false;

/* =========================
   UI refs
========================= */
const elTable = document.getElementById("table");
const elBoard = document.getElementById("board");
const elStage = document.getElementById("stage");
const elPot = document.getElementById("pot");
const elToCall = document.getElementById("tocall");
const elDealer = document.getElementById("dealer");
const elMsg = document.getElementById("msg");
const elLog = document.getElementById("log");

const btnStart = document.getElementById("btnStart");
const btnNextHand = document.getElementById("btnNextHand");
const btnFold = document.getElementById("btnFold");
const btnCall = document.getElementById("btnCall");
const btnRaise = document.getElementById("btnRaise");

/* =========================
   Helpers
========================= */
function logLine(s){
  elLog.textContent = (s + "\n" + elLog.textContent).slice(0, 6000);
}
function cardStr(c){ return c.r + c.s; }
function newDeck(){
  const d = [];
  for(const s of SUITS) for(const r of RANKS) d.push({r,s});
  for(let i=d.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}
function activePlayers(){
  return players.filter(p => !p.out);
}
function inHandPlayers(){
  return players.filter(p => !p.out && !p.folded);
}
function nextActiveIndex(from){
  const n = players.length;
  for(let k=1;k<=n;k++){
    const i = (from + k) % n;
    if(!players[i].out && !players[i].folded) return i;
  }
  return from;
}
function nextNotOutIndex(from){
  const n = players.length;
  for(let k=1;k<=n;k++){
    const i = (from + k) % n;
    if(!players[i].out) return i;
  }
  return from;
}
function onlyOneLeftInHand(){
  return inHandPlayers().length === 1;
}
function awardPotTo(idx, reason){
  players[idx].chips += pot;
  logLine(`${players[idx].name} wins ${pot} ${reason||""}`.trim());
  pot = 0;
  handInProgress = false;
  stage = "IDLE";
  awaitingHuman = false;
  cleanupEliminations();
  checkTournamentWinner();
  render();
}
function cleanupEliminations(){
  for(const p of players){
    if(!p.out && p.chips <= 0){
      p.out = true;
      p.chips = 0;
      logLine(`${p.name} is OUT!`);
    }
  }
}
function checkTournamentWinner(){
  const alive = players.filter(p => !p.out);
  if(alive.length === 1){
    elMsg.textContent = `üèÜ CHAMPION: ${alive[0].name}!`;
    logLine(`üèÜ TOURNAMENT WINNER: ${alive[0].name}`);
    handInProgress = false;
    stage = "IDLE";
  }
}

/* =========================
   HAND EVALUATOR (real)
   returns {cat, tiebreak:Array}
   cat: 8 SF,7 Quads,6 FH,5 Flush,4 Straight,3 Trips,2 TwoPair,1 Pair,0 High
========================= */
function straightHigh(uniqueRanksDesc){
  // uniqueRanksDesc: [14..2]
  const set = new Set(uniqueRanksDesc);
  // wheel A-5
  if(set.has(14) && set.has(5) && set.has(4) && set.has(3) && set.has(2)) return 5;
  for(let hi=14;hi>=5;hi--){
    let ok=true;
    for(let d=0;d<5;d++){
      if(!set.has(hi-d)){ ok=false; break; }
    }
    if(ok) return hi;
  }
  return 0;
}
function evaluate7(cards){
  const ranks = cards.map(c=>RVAL[c.r]).sort((a,b)=>b-a);
  const suitMap = new Map();
  const countMap = new Map();
  for(const c of cards){
    suitMap.set(c.s, (suitMap.get(c.s)||0)+1);
    const v = RVAL[c.r];
    countMap.set(v, (countMap.get(v)||0)+1);
  }
  const unique = [...new Set(ranks)];
  unique.sort((a,b)=>b-a);

  // flush?
  let flushSuit = null;
  for(const [s,c] of suitMap.entries()){
    if(c>=5){ flushSuit = s; break; }
  }
  let flushRanks = null;
  if(flushSuit){
    flushRanks = cards.filter(c=>c.s===flushSuit).map(c=>RVAL[c.r]).sort((a,b)=>b-a);
  }

  // straight flush?
  if(flushRanks){
    const uniqFlush = [...new Set(flushRanks)];
    uniqFlush.sort((a,b)=>b-a);
    const sf = straightHigh(uniqFlush);
    if(sf){
      return { cat: 8, tiebreak: [sf] };
    }
  }

  // groups
  const groups = [...countMap.entries()]
    .map(([r,c])=>({r, c}))
    .sort((a,b)=> (b.c-a.c) || (b.r-a.r));

  const fours = groups.filter(g=>g.c===4).map(g=>g.r);
  const threes = groups.filter(g=>g.c===3).map(g=>g.r);
  const pairs  = groups.filter(g=>g.c===2).map(g=>g.r);

  // quads
  if(fours.length){
    const quad = Math.max(...fours);
    const kicker = unique.find(r=>r!==quad);
    return { cat: 7, tiebreak: [quad, kicker] };
  }

  // full house
  if(threes.length){
    const trip = Math.max(...threes);
    const remainingTrips = threes.filter(r=>r!==trip);
    const bestPair = pairs.length ? Math.max(...pairs) : (remainingTrips.length ? Math.max(...remainingTrips) : 0);
    if(bestPair){
      return { cat: 6, tiebreak: [trip, bestPair] };
    }
  }

  // flush
  if(flushRanks){
    return { cat: 5, tiebreak: flushRanks.slice(0,5) };
  }

  // straight
  const st = straightHigh(unique);
  if(st){
    return { cat: 4, tiebreak: [st] };
  }

  // trips
  if(threes.length){
    const trip = Math.max(...threes);
    const kickers = unique.filter(r=>r!==trip).slice(0,2);
    return { cat: 3, tiebreak: [trip, ...kickers] };
  }

  // two pair
  if(pairs.length >= 2){
    const sortedPairs = [...pairs].sort((a,b)=>b-a);
    const p1 = sortedPairs[0], p2 = sortedPairs[1];
    const kicker = unique.find(r=>r!==p1 && r!==p2);
    return { cat: 2, tiebreak: [p1, p2, kicker] };
  }

  // one pair
  if(pairs.length === 1){
    const p = pairs[0];
    const kickers = unique.filter(r=>r!==p).slice(0,3);
    return { cat: 1, tiebreak: [p, ...kickers] };
  }

  // high card
  return { cat: 0, tiebreak: unique.slice(0,5) };
}
function compareEval(a,b){
  if(a.cat !== b.cat) return a.cat - b.cat;
  for(let i=0;i<Math.max(a.tiebreak.length,b.tiebreak.length);i++){
    const x=a.tiebreak[i]||0, y=b.tiebreak[i]||0;
    if(x!==y) return x-y;
  }
  return 0;
}
function catName(cat){
  return ["High","Pair","Two Pair","Trips","Straight","Flush","Full House","Quads","Straight Flush"][cat] || "Unknown";
}

/* =========================
   Betting
========================= */
function resetRoundBets(){
  for(const p of players){
    p.bet = 0;
  }
  toCall = 0;
  raisesThisRound = 0;
}
function postBlind(i, amount){
  const p = players[i];
  const pay = Math.min(amount, p.chips);
  p.chips -= pay;
  p.bet += pay;
  pot += pay;
}
function bettingRoundComplete(){
  const ps = inHandPlayers();
  for(const p of ps){
    if(p.chips === 0) continue; // all-in, ok
    if(p.bet !== toCall) return false;
  }
  return true;
}
function fixedRaiseSize(){
  // –±—ã—Å—Ç—Ä–æ: –ø—Ä–µ—Ñ–ª–æ–ø/—Ñ–ª–æ–ø = BB, —Ç–µ—Ä–Ω/—Ä–∏–≤–µ—Ä = 2*BB
  if(stage==="PREFLOP" || stage==="FLOP") return BIG_BLIND;
  if(stage==="TURN" || stage==="RIVER") return BIG_BLIND*2;
  return BIG_BLIND;
}

/* =========================
   Game flow
========================= */
function initTournament(){
  players = [];
  players.push({name:"YOU", isBot:false, chips:START_CHIPS, bet:0, folded:false, out:false, hand:[]});
  for(let i=1;i<=BOT_COUNT;i++){
    players.push({name:`BOT${i}`, isBot:true, chips:START_CHIPS, bet:0, folded:false, out:false, hand:[]});
  }
  dealer = 0;
  stage = "IDLE";
  pot = 0;
  board = [];
  toCall = 0;
  current = 0;
  awaitingHuman = false;
  tournamentStarted = true;
  handInProgress = false;
  elMsg.textContent = "Tournament ready. Press Next Hand.";
  logLine("Tournament started.");
  render();
}

function startHand(){
  if(!tournamentStarted) return;
  cleanupEliminations();
  checkTournamentWinner();
  if(players.filter(p=>!p.out).length < 2){
    render(); return;
  }

  handInProgress = true;
  deck = newDeck();
  board = [];
  pot = 0;

  for(const p of players){
    p.folded = false;
    p.bet = 0;
    p.hand = [];
  }

  // move dealer to next alive
  dealer = nextNotOutIndex(dealer);
  sb = nextNotOutIndex(dealer);
  bb = nextNotOutIndex(sb);

  // deal
  for(let r=0;r<2;r++){
    for(const p of players){
      if(!p.out){
        p.hand.push(deck.pop());
      }
    }
  }

  // blinds
  resetRoundBets();
  postBlind(sb, SMALL_BLIND);
  postBlind(bb, BIG_BLIND);
  toCall = Math.max(players[sb].bet, players[bb].bet);

  stage = "PREFLOP";
  current = nextActiveIndex(bb); // first action after BB
  awaitingHuman = false;

  logLine(`--- New hand --- Dealer: ${players[dealer].name} | SB:${players[sb].name} BB:${players[bb].name}`);
  render();
  tick(); // kick bots if needed
}

function advanceStage(){
  // reset bets for new street
  for(const p of players) p.bet = 0;
  toCall = 0;
  raisesThisRound = 0;

  if(stage==="PREFLOP"){
    board.push(deck.pop(), deck.pop(), deck.pop());
    stage="FLOP";
  } else if(stage==="FLOP"){
    board.push(deck.pop());
    stage="TURN";
  } else if(stage==="TURN"){
    board.push(deck.pop());
    stage="RIVER";
  } else if(stage==="RIVER"){
    stage="SHOWDOWN";
  }

  // first action postflop: next after dealer
  current = nextActiveIndex(dealer);
  awaitingHuman = false;

  if(stage==="SHOWDOWN"){
    doShowdown();
    return;
  }

  logLine(`Stage: ${stage}`);
  render();
}

function doShowdown(){
  const contenders = inHandPlayers();
  if(contenders.length === 1){
    const idx = players.indexOf(contenders[0]);
    awardPotTo(idx, "(everyone folded)");
    return;
  }

  // evaluate
  const evals = contenders.map(p => {
    const seven = [...p.hand, ...board];
    const e = evaluate7(seven);
    return { p, e };
  });

  evals.sort((a,b)=>compareEval(a.e,b.e)); // ascending
  const best = evals[evals.length-1].e;
  const winners = evals.filter(x => compareEval(x.e, best)===0).map(x => x.p);

  const winNames = winners.map(w=>w.name).join(", ");
  logLine(`Showdown best: ${catName(best.cat)} | Winners: ${winNames}`);

  // split pot
  const share = Math.floor(pot / winners.length);
  let rem = pot - share*winners.length;
  for(const w of winners){
    w.chips += share;
    if(rem>0){ w.chips += 1; rem--; } // –æ—Å—Ç–∞—Ç–æ–∫ –ø–æ 1 —Ñ–∏—à–∫–µ
  }
  pot = 0;

  handInProgress = false;
  stage = "IDLE";
  cleanupEliminations();
  checkTournamentWinner();
  render();
}

function playerFold(i){
  players[i].folded = true;
  logLine(`${players[i].name} folds`);
  render();
  if(onlyOneLeftInHand()){
    const winner = inHandPlayers()[0];
    awardPotTo(players.indexOf(winner), "(everyone folded)");
    return;
  }
  current = nextActiveIndex(i);
  tick();
}

function playerCall(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  const pay = Math.min(need, p.chips);
  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  logLine(`${p.name} ${need===0 ? "checks" : "calls"} ${pay}`);
  render();

  current = nextActiveIndex(i);
  if(bettingRoundComplete()){
    advanceStage();
    return;
  }
  tick();
}

function playerRaise(i){
  if(raisesThisRound >= MAX_RAISES_PER_ROUND){
    // –µ—Å–ª–∏ –ª–∏–º–∏—Ç —Ä–µ–π–∑–æ–≤ ‚Äî –ø—Ä–æ—Å—Ç–æ –∫–æ–ª–ª
    playerCall(i);
    return;
  }
  const p = players[i];
  const size = fixedRaiseSize();
  const needToCall = Math.max(0, toCall - p.bet);
  const totalAdd = Math.min(needToCall + size, p.chips);
  if(totalAdd <= 0){
    playerCall(i);
    return;
  }
  p.chips -= totalAdd;
  p.bet += totalAdd;
  pot += totalAdd;
  toCall = Math.max(toCall, p.bet);
  raisesThisRound++;

  logLine(`${p.name} raises (to ${p.bet})`);
  render();

  current = nextActiveIndex(i);
  tick();
}

/* =========================
   Bot AI (simple but fair)
========================= */
function botDecision(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);

  // –æ—Ü–µ–Ω–∫–∞ —Ç–µ–∫—É—â–µ–π —Å–∏–ª—ã (—Ä–µ–∞–ª—å–Ω–∞—è –∫–æ–º–±–∏–Ω–∞—Ü–∏—è –Ω–∞ –¥–æ—Å–∫–µ + —Ä—É–∫–∞)
  const seven = [...p.hand, ...board];
  const e = evaluate7(seven.length>=5 ? seven : seven); // –Ω–∞ –ø—Ä–µ—Ñ–ª–æ–ø–µ –ø—Ä–æ—Å—Ç–æ "–ø—Ä–æ—Å—Ç–∞—è" —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –Ω–∏–∂–µ
  let score = 0.35; // –±–∞–∑–æ–≤–æ

  if(stage==="PREFLOP"){
    const a = RVAL[p.hand[0].r], b = RVAL[p.hand[1].r];
    const pair = p.hand[0].r === p.hand[1].r;
    const suited = p.hand[0].s === p.hand[1].s;
    const high = Math.max(a,b);
    score = (pair?0.6:0) + (high/14)*0.35 + (suited?0.05:0);
  } else {
    // –ø–æ—Å–ª–µ —Ñ–ª–æ–ø–∞: –∫–∞—Ç–µ–≥–æ—Ä–∏—è —Å–∏–ª—å–Ω–æ –≤–ª–∏—è–µ—Ç
    score = 0.15 + (e.cat/8)*0.75;
    // —á—É—Ç—å —Ä–∞–Ω–¥–æ–º–∞
    score += (Math.random()-0.5)*0.10;
  }

  // –µ—Å–ª–∏ –∫–æ–ª–ª –¥–æ—Ä–æ–≥–æ–π –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Å—Ç–µ–∫–∞ ‚Äî –æ—Å—Ç–æ—Ä–æ–∂–Ω–µ–µ
  const stack = Math.max(1, p.chips);
  const pressure = need / stack;

  // –†–µ—à–µ–Ω–∏–µ
  if(score < 0.28 && pressure > 0.12 && Math.random() < 0.75) return "FOLD";
  if(score > 0.70 && p.chips > need + fixedRaiseSize() && Math.random() < 0.55) return "RAISE";
  if(need === 0 && score > 0.62 && p.chips > fixedRaiseSize() && Math.random() < 0.35) return "RAISE";
  return "CALL";
}

/* =========================
   Tick loop
========================= */
function tick(){
  if(!handInProgress) { updateButtons(); return; }
  if(stage==="IDLE" || stage==="SHOWDOWN") { updateButtons(); return; }

  // skip if current is folded/out
  if(players[current].out || players[current].folded){
    current = nextActiveIndex(current);
  }

  // human turn?
  if(!players[current].isBot){
    awaitingHuman = true;
    elMsg.textContent = `–¢–≤–æ–π —Ö–æ–¥: Fold / Call-Check / Raise`;
    updateButtons();
    return;
  }

  // bot acts
  awaitingHuman = false;
  updateButtons();

  // if only one left
  if(onlyOneLeftInHand()){
    const winner = inHandPlayers()[0];
    awardPotTo(players.indexOf(winner), "(everyone folded)");
    return;
  }

  const d = botDecision(current);
  if(d==="FOLD") playerFold(current);
  else if(d==="RAISE") playerRaise(current);
  else playerCall(current);
}

/* =========================
   Rendering
========================= */
function render(){
  // clear old seats
  [...elTable.querySelectorAll(".seat")].forEach(n=>n.remove());

  // board
  elBoard.innerHTML = "";
  for(let i=0;i<5;i++){
    const c = board[i];
    elBoard.appendChild(makeCardEl(c ? cardStr(c) : "", !c));
  }

  elStage.textContent = stage;
  elPot.textContent = pot;
  elToCall.textContent = toCall;
  elDealer.textContent = tournamentStarted ? players[dealer]?.name ?? "-" : "-";

  // message default
  if(!tournamentStarted){
    elMsg.textContent = "–ù–∞–∂–º–∏ ‚ÄúStart Tournament‚Äù.";
  } else if(!handInProgress && players.filter(p=>!p.out).length>=2){
    elMsg.textContent = "–ù–∞–∂–º–∏ ‚ÄúNext Hand‚Äù.";
  }

  // seats positions (YOU bottom pos-0, rest around)
  const seatPos = ["pos-0","pos-1","pos-2","pos-3","pos-4","pos-5"];

  for(let i=0;i<players.length;i++){
    const p = players[i];
    const seat = document.createElement("div");
    seat.className = `seat ${seatPos[i]||"pos-5"}`;

    const top = document.createElement("div");
    top.className = "top";

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = p.name;

    const tag = document.createElement("div");
    tag.className = "tag";
    if(p.out) { tag.classList.add("out"); tag.textContent = "OUT"; }
    else if(handInProgress && i===current && !p.folded) { tag.classList.add("turn"); tag.textContent = "TURN"; }
    else tag.textContent = p.isBot ? "BOT" : "YOU";

    top.appendChild(name);
    top.appendChild(tag);

    const meta = document.createElement("div");
    meta.className = "meta";
    meta.innerHTML = `<span>chips: <b>${p.chips}</b></span><span>${p.folded ? "<span style='color:var(--danger)'>folded</span>" : ""}</span>`;

    const cards = document.createElement("div");
    cards.className = "cards";

    const showCards = !p.isBot || stage==="SHOWDOWN" || !handInProgress;
    const hidden = p.isBot && handInProgress && stage!=="SHOWDOWN";
    const c1 = p.hand[0], c2 = p.hand[1];

    cards.appendChild(makeCardEl(c1 ? cardStr(c1) : "", hidden || !showCards));
    cards.appendChild(makeCardEl(c2 ? cardStr(c2) : "", hidden || !showCards));

    const bet = document.createElement("div");
    bet.className = "bet";
    bet.textContent = p.out ? "" : (p.bet>0 ? `Bet: ${p.bet}` : "");

    seat.appendChild(top);
    seat.appendChild(meta);
    seat.appendChild(cards);
    seat.appendChild(bet);

    elTable.appendChild(seat);
  }

  updateButtons();
}

function makeCardEl(text, hidden){
  const el = document.createElement("div");
  el.className = "card" + (hidden ? " hidden" : "");
  if(hidden){
    el.textContent = "üÇ†";
    return el;
  }
  if(!text){
    el.style.opacity = "0.35";
    el.textContent = "‚Äî";
    return el;
  }
  const r = text.slice(0,1);
  const s = text.slice(1);
  const small = document.createElement("small");
  small.textContent = r;
  const suit = document.createElement("div");
  suit.className = "suit";
  suit.textContent = s;
  el.appendChild(small);
  el.appendChild(suit);
  return el;
}

function updateButtons(){
  btnStart.disabled = tournamentStarted;
  btnNextHand.disabled = !tournamentStarted || handInProgress || players.filter(p=>!p.out).length<2;

  const yourTurn = tournamentStarted && handInProgress && awaitingHuman && current===0 && !players[0].folded && !players[0].out;
  btnFold.disabled = !yourTurn;
  btnCall.disabled = !yourTurn;
  btnRaise.disabled = !yourTurn || raisesThisRound >= MAX_RAISES_PER_ROUND;
}

/* =========================
   Buttons
========================= */
btnStart.addEventListener("click", () => {
  initTournament();
});
btnNextHand.addEventListener("click", () => {
  startHand();
});
btnFold.addEventListener("click", () => {
  if(awaitingHuman && current===0) { awaitingHuman=false; playerFold(0); }
});
btnCall.addEventListener("click", () => {
  if(awaitingHuman && current===0) { awaitingHuman=false; playerCall(0); }
});
btnRaise.addEventListener("click", () => {
  if(awaitingHuman && current===0) { awaitingHuman=false; playerRaise(0); }
});

/* Initial render */
render();
</script>
</body>
</html>
