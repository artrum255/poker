<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Poker ‚Äî Tournament + Shop</title>
<style>
  :root{
    --bg1:#071413;
    --bg2:#04100e;
    --felt1:#0f6a45;
    --felt2:#074c33;
    --line:#ffffff18;
    --glass:#0a1113cc;
    --text:#eaf5f1;
    --muted:#b5c9c1;
    --accent:#63f2c5;
    --warn:#ffd27a;
    --danger:#ff6b6b;
    --btn:#0b1417;
    --btn2:#0a1d1a;
    --card:#f7f8fc;
    --cardText:#0b0f12;
    --shadow:#00000070;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    color:var(--text);
    background: radial-gradient(1200px 720px at 50% 28%, #0f3a2e, var(--bg2));
    overflow:hidden;
  }

  /* FULL TABLE */
  .table{
    position:fixed; inset:0;
    background:
      radial-gradient(130% 110% at 50% 42%, var(--felt1), var(--felt2));
    overflow:hidden;
  }
  .table::before{
    content:"";
    position:absolute;
    inset:min(3.6vh, 26px);
    border-radius:999px;
    border:2px solid #ffffff14;
    pointer-events:none;
  }
  .table::after{
    content:"";
    position:absolute; inset:0;
    background: radial-gradient(900px 520px at 50% 50%, transparent, #00000045);
    pointer-events:none;
  }

  /* TOP HUD */
  .hud{
    position:absolute;
    top:14px; left:50%;
    transform:translateX(-50%);
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:center;
    padding:8px;
    z-index:10;
  }
  .pill{
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding:7px 12px;
    border-radius:999px;
    background: #00000030;
    border:1px solid var(--line);
    color:var(--muted);
    font-size:14px;
    backdrop-filter: blur(8px);
  }
  .pill b{ color:var(--text); }

  /* Message */
  .msg{
    position:absolute;
    left:50%;
    top:92px;
    transform:translateX(-50%);
    width:min(760px, 92vw);
    text-align:center;
    font-size:14px;
    color:var(--text);
    opacity:.95;
    z-index:10;
    min-height:18px;
    text-shadow: 0 6px 18px #00000066;
  }

  /* Board */
  .center{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:min(760px, 92vw);
    z-index:6;
    text-align:center;
  }
  .board{
    display:flex;
    justify-content:center;
    gap:10px;
    flex-wrap:wrap;
    margin:0;
  }

  /* Seats */
  .seat{
    position:absolute;
    width:250px;
    padding:10px;
    border-radius:18px;
    background: linear-gradient(180deg, #071215cc, #07121599);
    border:1px solid var(--line);
    box-shadow: 0 14px 40px var(--shadow);
    backdrop-filter: blur(10px);
    z-index:8;
  }
  .seat .top{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom:8px;
  }
  .name{
    font-weight:900;
    letter-spacing:.2px;
  }
  .tag{
    font-size:12px;
    color:var(--muted);
    border:1px solid var(--line);
    padding:2px 9px;
    border-radius:999px;
    white-space:nowrap;
  }
  .tag.turn{ color:var(--accent); border-color:#63f2c540; }
  .tag.out{ color:var(--danger); border-color:#ff6b6b55; }
  .meta{
    display:flex;
    justify-content:space-between;
    gap:10px;
    font-size:13px;
    color:var(--muted);
    margin-bottom:8px;
  }
  .cards{
    display:flex;
    gap:8px;
    min-height:78px;
  }
  .cards.folded{ filter: grayscale(1); opacity:0.40; }

  .card{
    width:56px; height:76px;
    border-radius:12px;
    background: var(--card);
    color: var(--cardText);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:950;
    letter-spacing:.4px;
    box-shadow: 0 10px 22px #00000055;
    position:relative;
    border:1px solid #0000001c;
    opacity:1;
    transform: translateY(0) scale(1);
  }
  .card.hidden{
    background: linear-gradient(135deg, #153040, #0b1922);
    color:#ffffffaa;
    border-color:#ffffff18;
  }
  .card small{
    position:absolute;
    left:8px; top:6px;
    font-size:12px;
    font-weight:950;
    opacity:.92;
  }
  .card .suit{ font-size:22px; }
  .card.deal{
    opacity:0;
    transform: translateY(-10px) scale(0.96);
    animation: popin .28s ease forwards;
  }
  @keyframes popin{ to{ opacity:1; transform: translateY(0) scale(1);} }

  .bet{
    margin-top:8px;
    font-size:13px;
    color:var(--warn);
    min-height:16px;
  }

  /* Seat positions */
  .pos-0{ left:50%; bottom:96px; transform:translateX(-50%); } /* YOU, leave space for action bar */
  .pos-1{ left:18px; bottom:180px; }
  .pos-2{ left:18px; top:140px; }
  .pos-3{ left:50%; top:120px; transform:translateX(-50%); }
  .pos-4{ right:18px; top:140px; }
  .pos-5{ right:18px; bottom:180px; }

  /* Action bar bottom-right (requested) */
  .actionbar{
    position:absolute;
    right:14px;
    bottom:14px;
    display:flex;
    gap:10px;
    align-items:flex-end;
    z-index:20;
  }
  .actionbox{
    padding:10px;
    border-radius:18px;
    background: linear-gradient(180deg, #071215dd, #071215aa);
    border:1px solid var(--line);
    box-shadow: 0 18px 60px var(--shadow);
    backdrop-filter: blur(10px);
    min-width: 340px;
  }
  .actionrow{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }
  .btn{
    padding:10px 12px;
    border-radius:14px;
    border:1px solid var(--line);
    background: var(--btn);
    color:var(--text);
    font-weight:900;
    cursor:pointer;
    transition: transform .08s ease, border-color .12s ease, background .12s ease;
  }
  .btn:hover{ border-color:#ffffff35; }
  .btn:active{ transform: translateY(1px); }
  .btn:disabled{ opacity:.45; cursor:not-allowed; }
  .btn-accent{
    background: linear-gradient(180deg, #0d2b24, #071a16);
    border-color:#63f2c540;
  }
  .btn-warn{
    background: linear-gradient(180deg, #2a2416, #19140b);
    border-color:#ffd27a44;
  }
  .btn-danger{
    background: linear-gradient(180deg, #2b1012, #19080a);
    border-color:#ff6b6b55;
  }
  .mini{
    font-size:12px;
    color:var(--muted);
    margin-top:8px;
    display:flex;
    justify-content:space-between;
    gap:10px;
  }

  /* Chip fly */
  .chip-fly{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    padding:6px 10px;
    border-radius:999px;
    background:#00000055;
    border:1px solid var(--line);
    color:var(--warn);
    font-weight:950;
    font-size:13px;
    pointer-events:none;
    opacity:0;
    animation: fly .7s ease forwards;
    z-index:30;
  }
  @keyframes fly{
    0% { opacity:0; transform:translate(-50%,-50%) translateY(10px) scale(.95); }
    30%{ opacity:1; }
    100%{ opacity:0; transform:translate(-50%,-50%) translateY(-26px) scale(1); }
  }

  /* Overlay / modal */
  .overlay{
    position:fixed; inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:#00000088;
    z-index:50;
    padding:16px;
  }
  .modal{
    width:min(640px, 96vw);
    border-radius:20px;
    background: linear-gradient(180deg, #071215f2, #071215d8);
    border:1px solid var(--line);
    box-shadow: 0 20px 80px #000000aa;
    padding:14px;
  }
  .modal h2{ margin:0 0 10px; font-size:20px; }
  .field{
    display:flex;
    gap:8px;
    align-items:center;
  }
  .field input{
    width:100%;
    padding:10px 12px;
    border-radius:14px;
    border:1px solid var(--line);
    background:#0a1416;
    color:var(--text);
    outline:none;
    font-weight:900;
  }
  .menu-grid{
    display:grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap:10px;
    margin-top:12px;
  }
  @media (max-width: 760px){
    .menu-grid{ grid-template-columns:1fr; }
    .actionbox{ min-width: 280px; }
    .pos-0{ bottom:120px; }
  }
  .small{ font-size:13px; color:var(--muted); line-height:1.35; }
  .range{ width:100%; }
  .kv{ display:flex; justify-content:space-between; gap:10px; font-size:13px; color:var(--muted); }
  .kv b{ color:var(--text); }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

  /* Lobby mock */
  .lobby{
    display:grid;
    gap:10px;
    margin-top:10px;
  }
  .tbl{
    border:1px solid var(--line);
    border-radius:16px;
    padding:10px;
    background:#00000022;
  }
  .tbl-head{
    display:flex; justify-content:space-between; align-items:center;
    gap:10px; flex-wrap:wrap;
  }
  .seats-mini{ display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; }
  .seat-mini{
    padding:6px 8px;
    border:1px solid var(--line);
    border-radius:999px;
    color:var(--muted);
    font-size:12px;
    background:#00000022;
  }
  .seat-mini.you{ color:var(--accent); border-color:#63f2c540; }
</style>
</head>

<body>
<div class="table" id="table">
  <div class="hud">
    <span class="pill">üë§ <span id="hudNick">-</span></span>
    <span class="pill">üí∂ EUR: <b id="hudEur">0</b></span>
    <span class="pill">üí∞ Chips: <b id="hudWalletChips">0</b></span>
    <span class="pill">üÉè <span id="hudStage">IDLE</span></span>
    <span class="pill">Pot: <b id="hudPot">0</b></span>
    <span class="pill">To call: <b id="hudToCall">0</b></span>
    <span class="pill">Dealer: <b id="hudDealer">-</b></span>
  </div>

  <div class="msg" id="msg"></div>

  <div class="center">
    <div class="board" id="board"></div>
  </div>

  <div class="actionbar">
    <div class="actionbox">
      <div class="actionrow">
        <button class="btn btn-accent" id="btnMenu">‚ò∞ Menu</button>
        <button class="btn btn-warn" id="btnShop">üõí Shop</button>
        <button class="btn btn-accent" id="btnStartResume">Start/Resume</button>
        <button class="btn btn-accent" id="btnNextHand">Next Hand</button>
      </div>

      <div class="actionrow" style="margin-top:8px">
        <button class="btn btn-danger" id="btnFold">Fold</button>
        <button class="btn" id="btnCheck">Check</button>
        <button class="btn" id="btnCall">Call</button>
        <button class="btn btn-accent" id="btnRaise">Raise</button>
      </div>

      <div class="mini">
        <span>Raise min: <b id="raiseMin">0</b></span>
        <span>Raise max: <b id="raiseMax">0</b></span>
      </div>
    </div>
  </div>
</div>

<!-- Nick (ask immediately) -->
<div class="overlay" id="nickOverlay">
  <div class="modal">
    <h2>–í–≤–µ–¥–∏ –Ω–∏–∫</h2>
    <div class="field">
      <input id="nickInput" maxlength="20" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: artrum255" />
      <button class="btn btn-accent" id="nickOk">OK</button>
    </div>
    <div class="small" style="margin-top:8px">
      –ù–æ–≤—ã–π –Ω–∏–∫ –ø–æ–ª—É—á–∞–µ—Ç <b>1000 chips</b> –∏ <b>0 EUR</b>. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –±—Ä–∞—É–∑–µ—Ä–µ.
    </div>
  </div>
</div>

<!-- Menu -->
<div class="overlay" id="menuOverlay">
  <div class="modal">
    <h2>–ú–µ–Ω—é</h2>
    <div class="small">
      ‚Ä¢ <b>–¢—É—Ä–Ω–∏—Ä</b> ‚Äî —Ç—ã –ø—Ä–æ—Ç–∏–≤ –±–æ—Ç–æ–≤, –≤—ã–ª–µ—Ç –ø—Ä–∏ 0, +10 EUR –µ—Å–ª–∏ —Ç—ã —á–µ–º–ø–∏–æ–Ω.<br>
      ‚Ä¢ <b>–ú–∞–≥–∞–∑–∏–Ω</b> ‚Äî –ø–æ–∫—É–ø–∫–∞ —Ñ–∏—à–µ–∫ –∑–∞ EUR.<br>
      ‚Ä¢ <b>–ò–≥—Ä–∞—Ç—å</b> ‚Äî –¥–µ–º–æ-–ª–æ–±–±–∏ (—Ä–µ–∞–ª—å–Ω—ã–π –æ–Ω–ª–∞–π–Ω —Ç—Ä–µ–±—É–µ—Ç —Å–µ—Ä–≤–µ—Ä).
    </div>
    <div class="menu-grid">
      <button class="btn btn-accent" id="btnGoTournament">–¢—É—Ä–Ω–∏—Ä</button>
      <button class="btn btn-warn" id="btnGoShop">–ú–∞–≥–∞–∑–∏–Ω</button>
      <button class="btn" id="btnGoPlay">–ò–≥—Ä–∞—Ç—å</button>
    </div>
    <div class="field" style="margin-top:12px; justify-content:flex-end">
      <button class="btn" id="btnCloseMenu">Close</button>
    </div>
  </div>
</div>

<!-- Shop -->
<div class="overlay" id="shopOverlay">
  <div class="modal">
    <h2>üõí –ú–∞–≥–∞–∑–∏–Ω</h2>
    <div class="small">EUR: <b id="shopEur">0</b> | Wallet chips: <b id="shopChips">0</b></div>
    <div class="menu-grid" style="grid-template-columns:1fr; margin-top:12px">
      <button class="btn btn-accent" data-buy="1000">–ö—É–ø–∏—Ç—å 1 000 chips ‚Äî 10 EUR</button>
      <button class="btn btn-accent" data-buy="10000">–ö—É–ø–∏—Ç—å 10 000 chips ‚Äî 90 EUR</button>
      <button class="btn btn-accent" data-buy="100000">–ö—É–ø–∏—Ç—å 100 000 chips ‚Äî 390 EUR</button>
    </div>
    <div class="field" style="margin-top:12px; justify-content:space-between">
      <button class="btn" id="btnShopBackMenu">‚ò∞ Menu</button>
      <button class="btn" id="btnShopClose">Close</button>
    </div>
  </div>
</div>

<!-- Raise modal -->
<div class="overlay" id="raiseOverlay">
  <div class="modal">
    <h2>Raise</h2>
    <div class="small">–í—ã–±–µ—Ä–∏ —Å—É–º–º—É ‚Äúraise to‚Äù (–¥–æ –∫–∞–∫–æ–≥–æ –æ–±—â–µ–≥–æ bet –ø–æ–¥–Ω—è—Ç—å).</div>

    <div class="kv" style="margin-top:10px">
      <span>Raise to:</span>
      <span><b id="raiseToLabel">0</b></span>
    </div>
    <input class="range" id="raiseSlider" type="range" min="0" max="0" value="0"/>

    <div class="field" style="margin-top:10px">
      <input id="raiseInput" type="number" min="0" step="1" />
      <button class="btn btn-accent" id="btnRaiseConfirm">Confirm</button>
    </div>

    <div class="field" style="margin-top:10px; justify-content:space-between">
      <button class="btn" id="btnRaiseMin">Min</button>
      <button class="btn" id="btnRaiseHalf">Half stack</button>
      <button class="btn" id="btnRaiseAll">All-in</button>
      <button class="btn" id="btnRaiseClose">Close</button>
    </div>
  </div>
</div>

<!-- Play lobby (mock) -->
<div class="overlay" id="playOverlay">
  <div class="modal">
    <h2>üéÆ –ò–≥—Ä–∞—Ç—å (–¥–µ–º–æ-–ª–æ–±–±–∏)</h2>
    <div class="small">–¢—É—Ç ‚Äú–æ–Ω–ª–∞–π–Ω –∏–≥—Ä–æ–∫–∏‚Äù ‚Äî –∏–º–∏—Ç–∞—Ü–∏—è. –î–ª—è —Ä–µ–∞–ª—å–Ω—ã—Ö –∏–≥—Ä–æ–∫–æ–≤ –Ω—É–∂–µ–Ω —Å–µ—Ä–≤–µ—Ä.</div>
    <div class="lobby" id="lobby"></div>
    <div class="field" style="margin-top:12px; justify-content:space-between">
      <button class="btn" id="btnPlayBackMenu">‚ò∞ Menu</button>
      <button class="btn" id="btnPlayClose">Close</button>
    </div>
  </div>
</div>

<script>
/* ========= Settings ========= */
const START_CHIPS = 1000;
const SMALL_BLIND = 10;
const BIG_BLIND = 20;
const BOT_COUNT = 5;
const MAX_RAISES_PER_ROUND = 4;
const BOT_THINK_MS = 260;
const STREET_PAUSE_MS = 900; // <<< pauses between flop/turn/river/showdown

const SHOP_PRICES = { 1000:10, 10000:90, 100000:390 };

const SUITS = ["‚ô£","‚ô¶","‚ô•","‚ô†"];
const RANKS = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
const RVAL = Object.fromEntries(RANKS.map((r,i)=>[r, i+2]));

/* ========= State ========= */
let nick = null;
let saveKey = null;
let walletEUR = 0;
let walletChips = 0;

let view = "TOURNAMENT"; // TOURNAMENT/SHOP/PLAY

let players = [];
let deck = [];
let board = [];
let pot = 0;
let stage = "IDLE";
let dealer = 0, sb = 1, bb = 2;
let current = 0;
let toCall = 0;
let raisesThisRound = 0;
let awaitingHuman = false;
let tournamentStarted = false;
let handInProgress = false;

let botTimer = null;
let transitionTimer = null;

/* ========= UI ========= */
const elTable = document.getElementById("table");
const elBoard = document.getElementById("board");
const elMsg = document.getElementById("msg");
const elLog = document.getElementById("log"); // may not exist now; keep safe

const hudNick = document.getElementById("hudNick");
const hudEur = document.getElementById("hudEur");
const hudWalletChips = document.getElementById("hudWalletChips");
const hudStage = document.getElementById("hudStage");
const hudPot = document.getElementById("hudPot");
const hudToCall = document.getElementById("hudToCall");
const hudDealer = document.getElementById("hudDealer");

const btnMenu = document.getElementById("btnMenu");
const btnShop = document.getElementById("btnShop");
const btnStartResume = document.getElementById("btnStartResume");
const btnNextHand = document.getElementById("btnNextHand");

const btnFold = document.getElementById("btnFold");
const btnCheck = document.getElementById("btnCheck");
const btnCall = document.getElementById("btnCall");
const btnRaise = document.getElementById("btnRaise");

const raiseMinTop = document.getElementById("raiseMin");
const raiseMaxTop = document.getElementById("raiseMax");

const nickOverlay = document.getElementById("nickOverlay");
const nickInput = document.getElementById("nickInput");
const nickOk = document.getElementById("nickOk");

const menuOverlay = document.getElementById("menuOverlay");
const btnGoTournament = document.getElementById("btnGoTournament");
const btnGoShop = document.getElementById("btnGoShop");
const btnGoPlay = document.getElementById("btnGoPlay");
const btnCloseMenu = document.getElementById("btnCloseMenu");

const shopOverlay = document.getElementById("shopOverlay");
const shopEur = document.getElementById("shopEur");
const shopChips = document.getElementById("shopChips");
const btnShopClose = document.getElementById("btnShopClose");
const btnShopBackMenu = document.getElementById("btnShopBackMenu");

const raiseOverlay = document.getElementById("raiseOverlay");
const raiseSlider = document.getElementById("raiseSlider");
const raiseToLabel = document.getElementById("raiseToLabel");
const raiseInput = document.getElementById("raiseInput");
const btnRaiseConfirm = document.getElementById("btnRaiseConfirm");
const btnRaiseClose = document.getElementById("btnRaiseClose");
const btnRaiseMin = document.getElementById("btnRaiseMin");
const btnRaiseHalf = document.getElementById("btnRaiseHalf");
const btnRaiseAll = document.getElementById("btnRaiseAll");

const playOverlay = document.getElementById("playOverlay");
const lobby = document.getElementById("lobby");
const btnPlayClose = document.getElementById("btnPlayClose");
const btnPlayBackMenu = document.getElementById("btnPlayBackMenu");

/* ========= Persistence ========= */
function keyForNick(n){ return `poker_v3_${n.toLowerCase()}`; }

function saveAll(){
  if(!saveKey) return;
  const state = {
    version: 3,
    nick, walletEUR, walletChips,
    tournament: {
      players, deck, board, pot, stage,
      dealer, sb, bb, current, toCall, raisesThisRound,
      tournamentStarted, handInProgress
    }
  };
  localStorage.setItem(saveKey, JSON.stringify(state));
  localStorage.setItem("poker_last_nick", nick);
}
function loadAll(n){
  const k = keyForNick(n);
  const raw = localStorage.getItem(k);
  if(!raw) return null;
  try { return JSON.parse(raw); } catch { return null; }
}
function ensureProfile(){
  const st = loadAll(nick);
  if(!st){
    walletEUR = 0;
    walletChips = START_CHIPS;
    clearTournament();
    tournamentStarted = false;
    stage = "IDLE";
    saveAll();
    return;
  }
  walletEUR = Number(st.walletEUR ?? 0);
  walletChips = Number(st.walletChips ?? START_CHIPS);

  const t = st.tournament;
  if(t && t.players && t.players.length){
    players = t.players;
    deck = t.deck ?? [];
    board = t.board ?? [];
    pot = t.pot ?? 0;
    stage = t.stage ?? "IDLE";
    dealer = t.dealer ?? 0; sb = t.sb ?? 1; bb = t.bb ?? 2;
    current = t.current ?? 0;
    toCall = t.toCall ?? 0;
    raisesThisRound = t.raisesThisRound ?? 0;
    tournamentStarted = !!t.tournamentStarted;
    handInProgress = !!t.handInProgress;
    if(players[0] && !players[0].isBot) players[0].name = nick;
  } else {
    clearTournament();
  }
}

/* ========= Helpers ========= */
function show(el, yes){ el.style.display = yes ? "flex" : "none"; }
function chipFly(text){
  const el = document.createElement("div");
  el.className = "chip-fly";
  el.textContent = text;
  elTable.appendChild(el);
  setTimeout(()=>el.remove(), 750);
}
function newDeck(){
  const d = [];
  for(const s of SUITS) for(const r of RANKS) d.push({r,s});
  for(let i=d.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}
function inHandPlayers(){ return players.filter(p => !p.out && !p.folded); }
function nextActiveIndex(from){
  const n = players.length;
  for(let k=1;k<=n;k++){
    const i = (from + k) % n;
    if(!players[i].out && !players[i].folded) return i;
  }
  return from;
}
function nextNotOutIndex(from){
  const n = players.length;
  for(let k=1;k<=n;k++){
    const i = (from + k) % n;
    if(!players[i].out) return i;
  }
  return from;
}
function onlyOneLeftInHand(){ return inHandPlayers().length === 1; }
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

/* ========= Evaluator ========= */
function straightHigh(uniqueRanksDesc){
  const set = new Set(uniqueRanksDesc);
  if(set.has(14) && set.has(5) && set.has(4) && set.has(3) && set.has(2)) return 5;
  for(let hi=14;hi>=5;hi--){
    let ok=true;
    for(let d=0;d<5;d++){
      if(!set.has(hi-d)){ ok=false; break; }
    }
    if(ok) return hi;
  }
  return 0;
}
function evaluate7(cards){
  const ranks = cards.map(c=>RVAL[c.r]).sort((a,b)=>b-a);
  const suitMap = new Map();
  const countMap = new Map();
  for(const c of cards){
    suitMap.set(c.s, (suitMap.get(c.s)||0)+1);
    const v = RVAL[c.r];
    countMap.set(v, (countMap.get(v)||0)+1);
  }
  const unique = [...new Set(ranks)].sort((a,b)=>b-a);

  let flushSuit = null;
  for(const [s,c] of suitMap.entries()){
    if(c>=5){ flushSuit = s; break; }
  }
  let flushRanks = null;
  if(flushSuit){
    flushRanks = cards.filter(c=>c.s===flushSuit).map(c=>RVAL[c.r]).sort((a,b)=>b-a);
  }
  if(flushRanks){
    const uniqFlush = [...new Set(flushRanks)].sort((a,b)=>b-a);
    const sf = straightHigh(uniqFlush);
    if(sf) return { cat: 8, tiebreak: [sf] };
  }

  const groups = [...countMap.entries()].map(([r,c])=>({r,c}))
    .sort((a,b)=>(b.c-a.c)||(b.r-a.r));
  const fours = groups.filter(g=>g.c===4).map(g=>g.r);
  const threes = groups.filter(g=>g.c===3).map(g=>g.r);
  const pairs  = groups.filter(g=>g.c===2).map(g=>g.r);

  if(fours.length){
    const quad = Math.max(...fours);
    const kicker = unique.find(r=>r!==quad);
    return { cat: 7, tiebreak: [quad, kicker] };
  }
  if(threes.length){
    const trip = Math.max(...threes);
    const remainingTrips = threes.filter(r=>r!==trip);
    const bestPair = pairs.length ? Math.max(...pairs) : (remainingTrips.length ? Math.max(...remainingTrips) : 0);
    if(bestPair) return { cat: 6, tiebreak: [trip, bestPair] };
  }
  if(flushRanks) return { cat: 5, tiebreak: flushRanks.slice(0,5) };
  const st = straightHigh(unique);
  if(st) return { cat: 4, tiebreak: [st] };
  if(threes.length){
    const trip = Math.max(...threes);
    const kickers = unique.filter(r=>r!==trip).slice(0,2);
    return { cat: 3, tiebreak: [trip, ...kickers] };
  }
  if(pairs.length >= 2){
    const sortedPairs = [...pairs].sort((a,b)=>b-a);
    const p1 = sortedPairs[0], p2 = sortedPairs[1];
    const kicker = unique.find(r=>r!==p1 && r!==p2);
    return { cat: 2, tiebreak: [p1, p2, kicker] };
  }
  if(pairs.length === 1){
    const p = pairs[0];
    const kickers = unique.filter(r=>r!==p).slice(0,3);
    return { cat: 1, tiebreak: [p, ...kickers] };
  }
  return { cat: 0, tiebreak: unique.slice(0,5) };
}
function compareEval(a,b){
  if(a.cat !== b.cat) return a.cat - b.cat;
  for(let i=0;i<Math.max(a.tiebreak.length,b.tiebreak.length);i++){
    const x=a.tiebreak[i]||0, y=b.tiebreak[i]||0;
    if(x!==y) return x-y;
  }
  return 0;
}
function catName(cat){
  return ["High","Pair","Two Pair","Trips","Straight","Flush","Full House","Quads","Straight Flush"][cat] || "Unknown";
}

/* ========= Tournament ========= */
function clearTournament(){
  players = [];
  deck = [];
  board = [];
  pot = 0;
  stage = "IDLE";
  dealer = 0; sb = 1; bb = 2;
  current = 0; toCall = 0; raisesThisRound = 0;
  awaitingHuman = false;
  tournamentStarted = false;
  handInProgress = false;
}
function createTournament(){
  players = [];
  players.push({name:nick, isBot:false, chips:walletChips, bet:0, folded:false, out:false, hand:[]});
  for(let i=1;i<=BOT_COUNT;i++){
    players.push({name:`BOT${i}`, isBot:true, chips:walletChips, bet:0, folded:false, out:false, hand:[]});
  }
  dealer = 0; sb = 1; bb = 2;
  stage = "IDLE";
  pot = 0;
  board = [];
  toCall = 0; raisesThisRound = 0;
  awaitingHuman = false;
  tournamentStarted = true;
  handInProgress = false;
  elMsg.textContent = "–¢—É—Ä–Ω–∏—Ä —Å–æ–∑–¥–∞–Ω. –ñ–º–∏ Next Hand.";
  saveAll();
  render();
  tick();
}

function cleanupEliminations(){
  for(const p of players){
    if(!p.out && p.chips <= 0){
      p.out = true;
      p.chips = 0;
    }
  }
}
function checkTournamentWinner(){
  const alive = players.filter(p=>!p.out);
  if(alive.length === 1){
    const w = alive[0];
    elMsg.textContent = `üèÜ CHAMPION: ${w.name}!` + (w.name===nick ? " +10 EUR" : "");
    if(w.name === nick){
      walletEUR += 10;
      chipFly("+10 EUR");
    }
    handInProgress = false;
    stage = "IDLE";
    awaitingHuman = false;
    saveAll();
    renderHUD();
    updateButtons();
    return true;
  }
  return false;
}

function resetRoundBets(){
  for(const p of players) p.bet = 0;
  toCall = 0;
  raisesThisRound = 0;
}
function postBlind(i, amount){
  const p = players[i];
  const pay = Math.min(amount, p.chips);
  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  if(pay>0) chipFly(`-${pay}`);
}
function bettingRoundComplete(){
  const ps = inHandPlayers();
  for(const p of ps){
    if(p.chips === 0) continue;
    if(p.bet !== toCall) return false;
  }
  return true;
}
function minRaiseTo(){ return toCall + BIG_BLIND; }

function startHand(){
  if(!tournamentStarted) return;
  cleanupEliminations();
  if(checkTournamentWinner()) return;
  if(players.filter(p=>!p.out).length < 2) return;

  handInProgress = true;
  deck = newDeck();
  board = [];
  pot = 0;

  for(const p of players){
    p.folded = false; p.bet = 0; p.hand = [];
  }

  dealer = nextNotOutIndex(dealer);
  sb = nextNotOutIndex(dealer);
  bb = nextNotOutIndex(sb);

  for(let r=0;r<2;r++){
    for(const p of players) if(!p.out) p.hand.push(deck.pop());
  }

  resetRoundBets();
  postBlind(sb, SMALL_BLIND);
  postBlind(bb, BIG_BLIND);
  toCall = Math.max(players[sb].bet, players[bb].bet);

  stage = "PREFLOP";
  current = nextActiveIndex(bb);
  awaitingHuman = false;

  elMsg.textContent = "–†–∞–∑–¥–∞—á–∞ –Ω–∞—á–∞–ª–∞—Å—å.";
  saveAll();
  render();
  tick();
}

function pauseThen(fn, text){
  clearTimeout(transitionTimer);
  elMsg.textContent = text;
  updateButtons();
  transitionTimer = setTimeout(()=>{ fn(); }, STREET_PAUSE_MS);
}

function advanceStage(){
  // pause BEFORE revealing next street
  const nextText =
    stage==="PREFLOP" ? "–§–ª–æ–ø‚Ä¶" :
    stage==="FLOP" ? "–¢—ë—Ä–Ω‚Ä¶" :
    stage==="TURN" ? "–†–∏–≤–µ—Ä‚Ä¶" :
    stage==="RIVER" ? "–®–æ—É–¥–∞—É–Ω‚Ä¶" : "‚Ä¶";

  pauseThen(()=>{
    for(const p of players) p.bet = 0;
    toCall = 0;
    raisesThisRound = 0;

    if(stage==="PREFLOP"){
      board.push(deck.pop(), deck.pop(), deck.pop());
      stage="FLOP";
    } else if(stage==="FLOP"){
      board.push(deck.pop());
      stage="TURN";
    } else if(stage==="TURN"){
      board.push(deck.pop());
      stage="RIVER";
    } else if(stage==="RIVER"){
      stage="SHOWDOWN";
    }

    current = nextActiveIndex(dealer);
    awaitingHuman = false;

    saveAll();
    render();

    if(stage==="SHOWDOWN"){
      pauseThen(doShowdown, "–û—Ç–∫—Ä—ã–≤–∞–µ–º –∫–∞—Ä—Ç—ã‚Ä¶");
      return;
    }

    tick();
  }, nextText);
}

function doShowdown(){
  const contenders = inHandPlayers();
  if(contenders.length === 1){
    awardPotTo(players.indexOf(contenders[0]), "(everyone folded)");
    return;
  }

  const evals = contenders.map(p=>({p, e:evaluate7([...p.hand, ...board])}));
  evals.sort((a,b)=>compareEval(a.e,b.e));
  const best = evals[evals.length-1].e;
  const winners = evals.filter(x=>compareEval(x.e,best)===0).map(x=>x.p);

  elMsg.textContent = `–õ—É—á—à–µ–µ: ${catName(best.cat)} | –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winners.map(w=>w.name).join(", ")}`;

  const share = Math.floor(pot / winners.length);
  let rem = pot - share*winners.length;
  for(const w of winners){
    w.chips += share;
    if(rem>0){ w.chips += 1; rem--; }
  }
  chipFly(`+${pot}`);
  pot = 0;

  handInProgress = false;
  stage = "IDLE";
  awaitingHuman = false;
  cleanupEliminations();
  checkTournamentWinner();
  saveAll();
  render();
  tick();
}

function awardPotTo(idx, reason){
  players[idx].chips += pot;
  chipFly(`+${pot}`);
  elMsg.textContent = `${players[idx].name} wins ${pot} ${reason||""}`.trim();
  pot = 0;

  handInProgress = false;
  stage = "IDLE";
  awaitingHuman = false;

  cleanupEliminations();
  checkTournamentWinner();
  saveAll();
  render();
  tick();
}

function playerFold(i){
  players[i].folded = true;
  elMsg.textContent = `${players[i].name} folds`;
  saveAll();
  render();
  if(onlyOneLeftInHand()){
    awardPotTo(players.indexOf(inHandPlayers()[0]), "(everyone folded)");
    return;
  }
  current = nextActiveIndex(i);
  tick();
}

function playerCheck(i){
  // only allowed if need==0
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  if(need !== 0) return;
  elMsg.textContent = `${p.name} checks`;
  current = nextActiveIndex(i);
  saveAll();
  render();
  if(bettingRoundComplete()) return advanceStage();
  tick();
}

function playerCall(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  const pay = Math.min(need, p.chips);
  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  if(pay>0) chipFly(`-${pay}`);
  elMsg.textContent = `${p.name} calls ${pay}`;
  saveAll();
  render();
  current = nextActiveIndex(i);
  if(bettingRoundComplete()) return advanceStage();
  tick();
}

function playerRaiseTo(i, raiseTo){
  if(raisesThisRound >= MAX_RAISES_PER_ROUND) return playerCall(i);
  const p = players[i];

  raiseTo = Math.max(raiseTo, minRaiseTo());
  raiseTo = Math.min(raiseTo, p.bet + p.chips);

  const add = Math.max(0, raiseTo - p.bet);
  const pay = Math.min(add, p.chips);
  if(pay<=0) return playerCall(i);

  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  toCall = Math.max(toCall, p.bet);
  raisesThisRound++;

  chipFly(`-${pay}`);
  elMsg.textContent = `${p.name} raises to ${p.bet}`;
  saveAll();
  render();

  current = nextActiveIndex(i);
  tick();
}

/* ========= Bots ========= */
function botDecision(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  const stack = Math.max(1, p.chips);
  const potOdds = need / Math.max(1, pot + need);
  const pressure = need / (stack + 1);

  if(stage==="PREFLOP"){
    const a = RVAL[p.hand[0].r], b = RVAL[p.hand[1].r];
    const pair = p.hand[0].r === p.hand[1].r;
    const suited = p.hand[0].s === p.hand[1].s;
    const gap = Math.abs(a-b);
    const high = Math.max(a,b);

    let score = 0.0;
    score += pair ? 0.55 : 0.0;
    score += (high/14)*0.30;
    score += suited ? 0.08 : 0.0;
    score += (gap<=2) ? 0.06 : 0.0;
    score += (high>=12) ? 0.06 : 0.0;
    score += (Math.random()-0.5)*0.06;

    if(need===0){
      if(score>0.72 && raisesThisRound<MAX_RAISES_PER_ROUND && Math.random()<0.35) return "RAISE";
      return "CHECK";
    }
    if(score < 0.33 && (pressure>0.12 || potOdds>0.28) && Math.random()<0.80) return "FOLD";
    if(score > 0.74 && raisesThisRound<MAX_RAISES_PER_ROUND && p.chips > need + BIG_BLIND && Math.random()<0.50) return "RAISE";
    return "CALL";
  }

  const e = evaluate7([...p.hand, ...board]);
  let strength = (e.cat/8) + (Math.random()-0.5)*0.08;

  if(need===0){
    if(strength > 0.62 && raisesThisRound<MAX_RAISES_PER_ROUND && Math.random()<0.30) return "RAISE";
    return "CHECK";
  }
  if(strength < 0.25 && (pressure>0.14 || potOdds>0.30) && Math.random()<0.80) return "FOLD";
  if(strength > 0.70 && raisesThisRound<MAX_RAISES_PER_ROUND && Math.random()<0.40) return "RAISE";
  if(potOdds < 0.34) return "CALL";
  if(Math.random()<0.15) return "FOLD";
  return "CALL";
}

function botAct(){
  if(!handInProgress) return;
  if(players[current].out || players[current].folded) current = nextActiveIndex(current);

  if(onlyOneLeftInHand()) return awardPotTo(players.indexOf(inHandPlayers()[0]), "(everyone folded)");

  const d = botDecision(current);
  if(d==="FOLD") playerFold(current);
  else if(d==="CHECK") playerCheck(current);
  else if(d==="RAISE"){
    const p = players[current];
    const min = minRaiseTo();
    const maxTo = p.bet + p.chips;
    let target = min + Math.floor(Math.random()*3)*BIG_BLIND;
    if(stage!=="PREFLOP"){
      const e = evaluate7([...p.hand,...board]);
      if(e.cat>=4) target += BIG_BLIND*3;
      if(e.cat>=6) target += BIG_BLIND*5;
    }
    target = clamp(target, min, maxTo);
    playerRaiseTo(current, target);
  } else {
    playerCall(current);
  }
}

/* ========= Tick ========= */
function tick(){
  clearTimeout(botTimer);

  if(view !== "TOURNAMENT"){
    updateButtons();
    updateRaiseLimitsTop();
    return;
  }

  cleanupEliminations();
  if(checkTournamentWinner()) return;

  if(!handInProgress || stage==="IDLE" || stage==="SHOWDOWN"){
    awaitingHuman = false;
    updateButtons();
    updateRaiseLimitsTop();
    return;
  }

  if(players[current].out || players[current].folded){
    current = nextActiveIndex(current);
  }

  if(!players[current].isBot){
    awaitingHuman = true;
    updateButtons();
    updateRaiseLimitsTop();
    return;
  }

  awaitingHuman = false;
  updateButtons();
  updateRaiseLimitsTop();

  elMsg.textContent = "–ë–æ—Ç –¥—É–º–∞–µ—Ç‚Ä¶";
  botTimer = setTimeout(()=>botAct(), BOT_THINK_MS);
}

/* ========= Render ========= */
function renderHUD(){
  hudNick.textContent = nick ?? "-";
  hudEur.textContent = String(walletEUR);
  hudWalletChips.textContent = String(walletChips);
  hudStage.textContent = stage;
  hudPot.textContent = String(pot);
  hudToCall.textContent = String(toCall);
  hudDealer.textContent = (tournamentStarted && players[dealer]) ? players[dealer].name : "-";
}

function makeCardEl(text, hidden, animate){
  const el = document.createElement("div");
  el.className = "card" + (hidden ? " hidden" : "") + (animate ? " deal" : "");
  if(hidden){ el.textContent = "üÇ†"; return el; }
  if(!text){ el.style.opacity="0.35"; el.textContent="‚Äî"; return el; }
  const r = text.slice(0,1), s = text.slice(1);
  const small = document.createElement("small"); small.textContent = r;
  const suit = document.createElement("div"); suit.className="suit"; suit.textContent = s;
  el.appendChild(small); el.appendChild(suit);
  return el;
}

function render(){
  // remove seats
  [...elTable.querySelectorAll(".seat")].forEach(n=>n.remove());

  // board
  elBoard.innerHTML = "";
  for(let i=0;i<5;i++){
    const c = board[i];
    elBoard.appendChild(makeCardEl(c ? (c.r+c.s) : "", !c, !!c));
  }

  renderHUD();

  const seatPos = ["pos-0","pos-1","pos-2","pos-3","pos-4","pos-5"];
  for(let i=0;i<players.length;i++){
    const p = players[i];
    const seat = document.createElement("div");
    seat.className = `seat ${seatPos[i]||"pos-5"}`;

    const top = document.createElement("div");
    top.className="top";

    const nm = document.createElement("div");
    nm.className="name"; nm.textContent = p.name;

    const tag = document.createElement("div");
    tag.className="tag";
    if(p.out){ tag.classList.add("out"); tag.textContent="OUT"; }
    else if(handInProgress && i===current && !p.folded){ tag.classList.add("turn"); tag.textContent="TURN"; }
    else tag.textContent = p.isBot ? "BOT" : "YOU";

    top.appendChild(nm); top.appendChild(tag);

    const meta = document.createElement("div");
    meta.className="meta";
    meta.innerHTML = `<span>chips: <b>${p.chips}</b></span><span>${p.folded ? "<span style='color:var(--danger)'>folded</span>" : ""}</span>`;

    const cards = document.createElement("div");
    cards.className="cards" + ((i===0 && p.folded) ? " folded" : "");

    const hidden = p.isBot && handInProgress && stage!=="SHOWDOWN";
    const show = !p.isBot || stage==="SHOWDOWN" || !handInProgress;
    const c1 = p.hand?.[0], c2 = p.hand?.[1];
    cards.appendChild(makeCardEl(c1 ? (c1.r+c1.s) : "", hidden || !show, !!c1));
    cards.appendChild(makeCardEl(c2 ? (c2.r+c2.s) : "", hidden || !show, !!c2));

    const bet = document.createElement("div");
    bet.className="bet";
    bet.textContent = p.out ? "" : (p.bet>0 ? `Bet: ${p.bet}` : "");

    seat.appendChild(top);
    seat.appendChild(meta);
    seat.appendChild(cards);
    seat.appendChild(bet);

    elTable.appendChild(seat);
  }

  updateButtons();
  updateRaiseLimitsTop();
}

function updateButtons(){
  const inT = (view === "TOURNAMENT");
  btnStartResume.disabled = !nick;
  btnNextHand.disabled = !(inT && tournamentStarted && !handInProgress && players.filter(p=>!p.out).length>=2);

  const yourTurn = inT && tournamentStarted && handInProgress && awaitingHuman && current===0 && !players[0].out && !players[0].folded;
  const you = players[0];

  btnFold.disabled = !yourTurn;

  // separate check/call
  let need = 0;
  if(you && handInProgress) need = Math.max(0, toCall - you.bet);

  btnCheck.disabled = !(yourTurn && need===0);
  btnCall.disabled  = !(yourTurn && need>0);

  btnRaise.disabled = !(yourTurn && raisesThisRound < MAX_RAISES_PER_ROUND);
}

function updateRaiseLimitsTop(){
  const you = players[0];
  if(!you || !handInProgress || view!=="TOURNAMENT"){
    raiseMinTop.textContent = "0";
    raiseMaxTop.textContent = "0";
    return;
  }
  const minTo = clamp(minRaiseTo(), 0, you.bet + you.chips);
  const maxTo = you.bet + you.chips;
  raiseMinTop.textContent = String(minTo);
  raiseMaxTop.textContent = String(maxTo);
}

/* ========= Views / Menu ========= */
function openMenu(){ show(menuOverlay,true); }
function closeMenu(){ show(menuOverlay,false); }

function openShop(){
  view="SHOP";
  shopEur.textContent = String(walletEUR);
  shopChips.textContent = String(walletChips);
  show(shopOverlay,true);
  show(playOverlay,false);
  closeMenu();
  tick();
}
function closeShop(){
  show(shopOverlay,false);
  if(view==="SHOP") view="TOURNAMENT";
  tick(); render();
}
function openPlay(){
  view="PLAY";
  buildLobby();
  show(playOverlay,true);
  show(shopOverlay,false);
  closeMenu();
  tick();
}
function closePlay(){
  show(playOverlay,false);
  if(view==="PLAY") view="TOURNAMENT";
  tick(); render();
}
function goTournament(){
  view="TOURNAMENT";
  show(shopOverlay,false);
  show(playOverlay,false);
  closeMenu();
  tick(); render();
}

/* ========= Lobby mock ========= */
function randomNick(){
  const a = ["neo","max","viper","fox","jazz","storm","ace","byte","wolf","kira","mike","zero","rex","iris","nova"];
  const b = Math.floor(Math.random()*900)+100;
  return a[Math.floor(Math.random()*a.length)] + b;
}
function buildLobby(){
  lobby.innerHTML = "";
  const tables = [
    {name:"Table #1"}, {name:"Table #2"}, {name:"Table #3"}
  ];
  for(const t of tables){
    const box = document.createElement("div");
    box.className="tbl";
    const head = document.createElement("div");
    head.className="tbl-head";
    head.innerHTML = `<b>${t.name}</b><span class="pill">Players online: <b>${Math.floor(Math.random()*6)+1}</b></span>`;
    const seats = document.createElement("div");
    seats.className="seats-mini";

    const youSeat = document.createElement("span");
    youSeat.className="seat-mini you";
    youSeat.textContent = nick ? `${nick} (you)` : "you";
    seats.appendChild(youSeat);

    const count = Math.floor(Math.random()*5)+1;
    for(let i=0;i<count;i++){
      const s = document.createElement("span");
      s.className="seat-mini";
      s.textContent = randomNick();
      seats.appendChild(s);
    }

    const join = document.createElement("button");
    join.className="btn btn-accent";
    join.textContent="Join (demo)";
    join.onclick = ()=> alert("–≠—Ç–æ –¥–µ–º–æ –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞. –î–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –æ–Ω–ª–∞–π–Ω–∞ –Ω—É–∂–µ–Ω –±—ç–∫–µ–Ω–¥ (WebSocket/Firebase).");

    box.appendChild(head);
    box.appendChild(seats);
    box.appendChild(join);
    lobby.appendChild(box);
  }
}

/* ========= Shop ========= */
function buyChips(chips){
  const price = SHOP_PRICES[chips];
  if(walletEUR < price){
    alert(`–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç EUR. –ù—É–∂–Ω–æ ${price}, —É —Ç–µ–±—è ${walletEUR}.`);
    return;
  }
  walletEUR -= price;
  walletChips += chips;
  chipFly(`-${price} EUR`);
  shopEur.textContent = String(walletEUR);
  shopChips.textContent = String(walletChips);
  renderHUD();
  saveAll();
}

/* ========= Raise modal ========= */
function openRaise(){
  const you = players[0];
  if(!you || !handInProgress) return;
  const minTo = clamp(minRaiseTo(), 0, you.bet + you.chips);
  const maxTo = you.bet + you.chips;

  raiseSlider.min = String(minTo);
  raiseSlider.max = String(maxTo);
  raiseSlider.value = String(minTo);

  raiseToLabel.textContent = String(minTo);
  raiseInput.value = String(minTo);
  raiseInput.min = String(minTo);
  raiseInput.max = String(maxTo);

  show(raiseOverlay,true);
}
function closeRaise(){ show(raiseOverlay,false); }
function syncRaiseFromSlider(){
  const v = Number(raiseSlider.value);
  raiseToLabel.textContent = String(v);
  raiseInput.value = String(v);
}
function syncRaiseFromInput(){
  const you = players[0];
  const minTo = clamp(minRaiseTo(), 0, you.bet + you.chips);
  const maxTo = you.bet + you.chips;
  let v = Number(raiseInput.value || minTo);
  v = clamp(v, minTo, maxTo);
  raiseInput.value = String(v);
  raiseSlider.value = String(v);
  raiseToLabel.textContent = String(v);
}

/* ========= Events ========= */
btnMenu.addEventListener("click", openMenu);
btnCloseMenu.addEventListener("click", closeMenu);

btnGoTournament.addEventListener("click", goTournament);
btnGoShop.addEventListener("click", openShop);
btnGoPlay.addEventListener("click", openPlay);

btnShop.addEventListener("click", openShop);
btnShopBackMenu.addEventListener("click", ()=>{ closeShop(); openMenu(); });
btnShopClose.addEventListener("click", closeShop);

btnPlayBackMenu.addEventListener("click", ()=>{ closePlay(); openMenu(); });
btnPlayClose.addEventListener("click", closePlay);

shopOverlay.querySelectorAll("[data-buy]").forEach(b=>{
  b.addEventListener("click", ()=> buyChips(Number(b.getAttribute("data-buy"))));
});

btnStartResume.addEventListener("click", ()=>{
  if(!nick) return;
  if(!tournamentStarted) createTournament();
  render(); tick();
});

btnNextHand.addEventListener("click", startHand);

btnFold.addEventListener("click", ()=>{
  if(view==="TOURNAMENT" && awaitingHuman && current===0) { awaitingHuman=false; playerFold(0); }
});
btnCheck.addEventListener("click", ()=>{
  if(view==="TOURNAMENT" && awaitingHuman && current===0) { awaitingHuman=false; playerCheck(0); }
});
btnCall.addEventListener("click", ()=>{
  if(view==="TOURNAMENT" && awaitingHuman && current===0) { awaitingHuman=false; playerCall(0); }
});
btnRaise.addEventListener("click", ()=>{
  if(view==="TOURNAMENT" && awaitingHuman && current===0) openRaise();
});

raiseSlider.addEventListener("input", syncRaiseFromSlider);
raiseInput.addEventListener("input", syncRaiseFromInput);

btnRaiseClose.addEventListener("click", closeRaise);
btnRaiseConfirm.addEventListener("click", ()=>{
  const v = Number(raiseSlider.value);
  closeRaise();
  if(view==="TOURNAMENT" && awaitingHuman && current===0){
    awaitingHuman=false;
    playerRaiseTo(0, v);
  }
});
btnRaiseMin.addEventListener("click", ()=>{
  raiseSlider.value = raiseSlider.min;
  syncRaiseFromSlider();
});
btnRaiseAll.addEventListener("click", ()=>{
  raiseSlider.value = raiseSlider.max;
  syncRaiseFromSlider();
});
btnRaiseHalf.addEventListener("click", ()=>{
  const you = players[0];
  const maxTo = you.bet + you.chips;
  const minTo = Number(raiseSlider.min);
  const v = clamp(Math.floor((minTo + maxTo)/2), minTo, maxTo);
  raiseSlider.value = String(v);
  syncRaiseFromSlider();
});

/* ========= Nick (ask immediately) ========= */
function openNick(){
  show(nickOverlay,true);
  nickInput.focus();
}
function closeNick(){ show(nickOverlay,false); }

nickOk.addEventListener("click", ()=>{
  const n = nickInput.value.trim();
  if(!n){ nickInput.focus(); return; }
  nick = n;
  saveKey = keyForNick(nick);
  ensureProfile();
  closeNick();
  elMsg.textContent = "–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º –≤ –º–µ–Ω—é.";
  render();
  tick();
  openMenu();
});
nickInput.addEventListener("keydown", (e)=>{ if(e.key==="Enter") nickOk.click(); });

/* ========= Bot scheduling ========= */
function botTick(){
  clearTimeout(botTimer);
  if(view!=="TOURNAMENT") return;
  if(!handInProgress || stage==="IDLE" || stage==="SHOWDOWN") return;
  if(players[current].out || players[current].folded) current = nextActiveIndex(current);

  if(!players[current].isBot){
    awaitingHuman = true;
    updateButtons();
    updateRaiseLimitsTop();
    return;
  }
  awaitingHuman = false;
  updateButtons();
  updateRaiseLimitsTop();
  elMsg.textContent = "–ë–æ—Ç –¥—É–º–∞–µ—Ç‚Ä¶";
  botTimer = setTimeout(()=>botAct(), BOT_THINK_MS);
}

/* Replace tick with botTick + state checks */
function tick(){
  clearTimeout(botTimer);
  if(view!=="TOURNAMENT"){
    updateButtons(); updateRaiseLimitsTop(); return;
  }
  cleanupEliminations();
  if(checkTournamentWinner()) return;

  if(!handInProgress || stage==="IDLE" || stage==="SHOWDOWN"){
    awaitingHuman = false;
    updateButtons(); updateRaiseLimitsTop(); return;
  }
  botTick();
}

/* ========= Boot ========= */
function boot(){
  // ask immediately
  const last = localStorage.getItem("poker_last_nick");
  openNick();
  if(last){
    nickInput.value = last;
    nickInput.select();
  }
  elMsg.textContent = "";
  renderHUD();
  render();
  updateButtons();
  updateRaiseLimitsTop();
}
boot();

/* ========= Render safe call (initial no players) ========= */
function safeInit(){
  if(players.length===0){
    // minimal placeholders so render doesn't crash before tournament created
    players = [
      {name:"YOU", isBot:false, chips:0, bet:0, folded:false, out:false, hand:[]},
      {name:"BOT1", isBot:true, chips:0, bet:0, folded:false, out:false, hand:[]},
      {name:"BOT2", isBot:true, chips:0, bet:0, folded:false, out:false, hand:[]},
      {name:"BOT3", isBot:true, chips:0, bet:0, folded:false, out:false, hand:[]},
      {name:"BOT4", isBot:true, chips:0, bet:0, folded:false, out:false, hand:[]},
      {name:"BOT5", isBot:true, chips:0, bet:0, folded:false, out:false, hand:[]},
    ];
    render();
  }
}
safeInit();
</script>
</body>
</html>
