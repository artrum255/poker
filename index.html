<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Poker Tournament (Nick Save + Shop)</title>
<style>
  :root{
    --bg:#08150f;
    --felt:#146b3a;
    --felt2:#0f5a30;
    --panel:#0b0f12cc;
    --text:#e9f2ec;
    --muted:#b9c9bf;
    --accent:#66ffb3;
    --danger:#ff6b6b;
    --warn:#ffd166;
    --card:#f6f7fb;
    --cardText:#101316;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    background:radial-gradient(1200px 700px at 50% 35%, #174a33, var(--bg));
    color:var(--text);
  }
  .wrap{
    max-width:1150px;
    margin:0 auto;
    padding:16px;
    display:grid;
    gap:12px;
    grid-template-columns: 1fr 340px;
  }
  @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

  /* Table */
  .table{
    position:relative;
    height:650px;
    border-radius:24px;
    background: radial-gradient(120% 100% at 50% 40%, var(--felt), var(--felt2));
    box-shadow: 0 18px 60px #00000066;
    overflow:hidden;
    border:1px solid #ffffff1a;
  }
  .table::before{
    content:"";
    position:absolute; inset:22px;
    border-radius:999px;
    border:2px solid #ffffff1c;
    pointer-events:none;
  }
  .center{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:min(620px, 94%);
    text-align:center;
  }
  .board{
    display:flex;
    gap:8px;
    justify-content:center;
    flex-wrap:wrap;
    margin:10px 0 6px;
  }
  .chipline{
    display:flex;
    justify-content:center;
    gap:12px;
    flex-wrap:wrap;
    color:var(--muted);
    font-size:14px;
  }
  .pill{
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding:6px 10px;
    border-radius:999px;
    background:#0000002a;
    border:1px solid #ffffff12;
  }
  .msg{
    margin-top:10px;
    font-size:14px;
    color:var(--text);
    opacity:.95;
    min-height:18px;
  }

  /* Seats */
  .seat{
    position:absolute;
    width:230px;
    padding:10px;
    border-radius:16px;
    background: linear-gradient(180deg, #0b0f12cc, #0b0f1299);
    border:1px solid #ffffff14;
    box-shadow: 0 10px 30px #00000055;
    backdrop-filter: blur(6px);
  }
  .seat .top{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom:8px;
  }
  .name{
    font-weight:800;
    letter-spacing:.2px;
  }
  .tag{
    font-size:12px;
    color:var(--muted);
    border:1px solid #ffffff18;
    padding:2px 8px;
    border-radius:999px;
    white-space:nowrap;
  }
  .tag.turn{ color:var(--accent); border-color:#66ffb340; }
  .tag.out{ color:var(--danger); border-color:#ff6b6b55; }
  .meta{
    display:flex;
    justify-content:space-between;
    font-size:13px;
    color:var(--muted);
    margin-bottom:8px;
    gap:10px;
  }
  .meta .chips{ white-space:nowrap; }
  .cards{
    display:flex;
    gap:8px;
    min-height:78px;
  }

  /* Cards + animations */
  .card{
    width:56px;
    height:76px;
    border-radius:10px;
    background: var(--card);
    color:var(--cardText);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    letter-spacing:.4px;
    box-shadow: 0 8px 18px #00000055;
    position:relative;
    border:1px solid #00000022;
    transform: translateY(0) scale(1);
    transition: transform .25s ease, opacity .25s ease;
  }
  .card.hidden{
    background: linear-gradient(135deg, #1b2a3a, #0e1722);
    color:#ffffffaa;
    border-color:#ffffff1a;
  }
  .card small{
    position:absolute;
    left:8px; top:6px;
    font-size:12px;
    font-weight:900;
    opacity:.9;
  }
  .card .suit{ font-size:22px; }
  .card.deal{
    transform: translateY(-10px) scale(0.95);
    opacity:0.0;
    animation: popin .28s ease forwards;
  }
  @keyframes popin{
    to { transform: translateY(0) scale(1); opacity:1; }
  }

  /* Chip animation bubble */
  .chip-fly{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    padding:6px 10px;
    border-radius:999px;
    background:#00000055;
    border:1px solid #ffffff1a;
    color:var(--warn);
    font-weight:800;
    font-size:13px;
    pointer-events:none;
    opacity:0;
    animation: fly .7s ease forwards;
  }
  @keyframes fly{
    0% { opacity:0; transform:translate(-50%,-50%) translateY(10px) scale(.95); }
    30%{ opacity:1; }
    100%{ opacity:0; transform:translate(-50%,-50%) translateY(-26px) scale(1); }
  }

  .bet{
    margin-top:8px;
    font-size:13px;
    color:var(--warn);
    min-height:16px;
  }

  /* Seat positions (up to 6) */
  .pos-0{ left:50%; bottom:14px; transform:translateX(-50%); } /* YOU */
  .pos-1{ left:18px; bottom:150px; }
  .pos-2{ left:18px; top:100px; }
  .pos-3{ left:50%; top:14px; transform:translateX(-50%); }
  .pos-4{ right:18px; top:100px; }
  .pos-5{ right:18px; bottom:150px; }

  /* Side panel */
  .panel{
    padding:14px;
    border-radius:18px;
    background: linear-gradient(180deg, #0b0f12cc, #0b0f1299);
    border:1px solid #ffffff14;
    box-shadow: 0 10px 30px #00000055;
    backdrop-filter: blur(6px);
    height:650px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .panel h3{ margin:0; font-size:18px; }
  .controls{ display:grid; gap:8px; margin-top:6px; }
  button{
    padding:10px 12px;
    border-radius:12px;
    border:1px solid #ffffff18;
    background:#0b0f12;
    color:var(--text);
    font-weight:800;
    cursor:pointer;
  }
  button:hover{ border-color:#ffffff35; }
  button:disabled{ opacity:.45; cursor:not-allowed; }
  .btn-accent{
    background: linear-gradient(180deg, #1a3b2b, #0b1f16);
    border-color:#66ffb333;
  }
  .row{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }
  .small{
    font-size:13px;
    color:var(--muted);
    line-height:1.35;
  }
  .log{
    flex:1;
    overflow:auto;
    padding:10px;
    border-radius:14px;
    background:#00000022;
    border:1px solid #ffffff12;
    font-size:13px;
    color:var(--muted);
    white-space:pre-wrap;
  }
  input[type="range"]{ width:100%; }
  .kv{
    display:flex;
    justify-content:space-between;
    gap:10px;
    font-size:13px;
    color:var(--muted);
  }
  .kv b{ color:var(--text); }

  /* Modal */
  .modal-backdrop{
    position:fixed; inset:0;
    background:#00000088;
    display:none;
    align-items:center;
    justify-content:center;
    padding:16px;
    z-index:50;
  }
  .modal{
    width:min(520px, 96vw);
    border-radius:18px;
    background: linear-gradient(180deg, #0b0f12f0, #0b0f12cc);
    border:1px solid #ffffff18;
    box-shadow: 0 20px 80px #000000aa;
    padding:14px;
  }
  .modal h2{ margin:0 0 10px; font-size:18px; }
  .modal .field{
    display:flex; gap:8px; align-items:center;
  }
  .modal input{
    width:100%;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid #ffffff20;
    background:#0b0f12;
    color:var(--text);
    outline:none;
    font-weight:700;
  }
  .modal .hint{ margin-top:8px; font-size:13px; color:var(--muted); }
  .modal .actions{ margin-top:12px; display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
</style>
</head>

<body>
<div class="wrap">
  <div class="table" id="table">
    <div class="center">
      <div class="chipline">
        <span class="pill">üÉè <span id="stage">IDLE</span></span>
        <span class="pill">üí∞ Pot: <b id="pot">0</b></span>
        <span class="pill">üìû To call: <b id="tocall">0</b></span>
        <span class="pill">üü¢ Dealer: <b id="dealer">-</b></span>
      </div>
      <div class="board" id="board"></div>
      <div class="msg" id="msg">–ó–∞–≥—Ä—É–∂–∞—é‚Ä¶</div>
    </div>
  </div>

  <div class="panel">
    <h3>Controls</h3>

    <div class="row">
      <span class="pill">üë§ Nick: <b id="nick">-</b></span>
      <span class="pill">üí∂ EUR: <b id="eur" class="mono">‚àû</b></span>
      <button id="btnShop">üõí Shop</button>
      <button id="btnReset">Reset Nick Save</button>
    </div>

    <div class="controls">
      <button class="btn-accent" id="btnStart">Start / Resume</button>
      <button id="btnNextHand">Next Hand</button>
      <button id="btnFold">Fold</button>
      <button id="btnCall">Call / Check</button>
      <button id="btnRaise">Raise</button>
    </div>

    <div class="small">
      <b>–†–µ–π–∑-—Å—É–º–º–∞:</b>
      <div class="kv">
        <span>Raise to:</span>
        <span><b id="raiseToLabel">0</b></span>
      </div>
      <input id="raiseSlider" type="range" min="0" max="0" value="0" />
      <div class="kv">
        <span>–ú–∏–Ω–∏–º—É–º:</span><b id="raiseMin">0</b>
        <span>–ú–∞–∫—Å–∏–º—É–º:</span><b id="raiseMax">0</b>
      </div>
      <div style="margin-top:10px">
        <b>–¢—É—Ä–Ω–∏—Ä:</b> –µ—Å–ª–∏ —Ñ–∏—à–∫–∏ = 0 ‚Üí OUT. –ò–≥—Ä–∞ –¥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤—ã–∂–∏–≤—à–µ–≥–æ.
        –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–¥—ë—Ç –ø–æ –Ω–∏–∫—É (LocalStorage).
      </div>
    </div>

    <div class="log" id="log"></div>
  </div>
</div>

<!-- Nick modal -->
<div class="modal-backdrop" id="nickModal">
  <div class="modal">
    <h2>–í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫</h2>
    <div class="field">
      <input id="nickInput" maxlength="20" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: Artrum255" />
      <button class="btn-accent" id="nickOk">OK</button>
    </div>
    <div class="hint">
      –î–ª—è –Ω–æ–≤–æ–≥–æ –Ω–∏–∫–∞ –≤—ã–¥–∞—ë—Ç—Å—è <b>1000</b> —Å—Ç–∞—Ä—Ç–æ–≤—ã—Ö —Ñ–∏—à–µ–∫.
      –ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –±—Ä–∞—É–∑–µ—Ä–µ –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.
    </div>
  </div>
</div>

<!-- Shop modal -->
<div class="modal-backdrop" id="shopModal">
  <div class="modal">
    <h2>–ú–∞–≥–∞–∑–∏–Ω (EUR: ‚àû)</h2>
    <div class="small">–ú–æ–∂–Ω–æ –¥–æ–∫—É–ø–∏—Ç—å —Ñ–∏—à–∫–∏ (–µ–≤—Ä–æ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ, –ø—Ä–æ—Å—Ç–æ –¥–ª—è –∏–≥—Ä—ã).</div>
    <div class="actions" style="justify-content:flex-start; margin-top:10px">
      <button class="btn-accent" data-buy="1000">+1 000 chips</button>
      <button class="btn-accent" data-buy="10000">+10 000 chips</button>
      <button class="btn-accent" data-buy="100000">+100 000 chips</button>
      <button id="shopClose">Close</button>
    </div>
  </div>
</div>

<script>
/* =========================
   SETTINGS
========================= */
const START_CHIPS = 1000;
const SMALL_BLIND = 10;
const BIG_BLIND = 20;
const BOT_COUNT = 5;              // + YOU = 6 seats
const MAX_RAISES_PER_ROUND = 4;   // –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–µ–π–∑–æ–≤ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
const BOT_THINK_MS = 260;         // –∑–∞–¥–µ—Ä–∂–∫–∞ —Ö–æ–¥–∞ –±–æ—Ç–∞ (–∞–Ω–∏–º–∞—Ü–∏—è/–æ—â—É—â–µ–Ω–∏–µ)
const SUITS = ["‚ô£","‚ô¶","‚ô•","‚ô†"];
const RANKS = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
const RVAL = Object.fromEntries(RANKS.map((r,i)=>[r, i+2]));

/* =========================
   STATE
========================= */
let nick = null;
let saveKey = null;

let players = [];
let deck = [];
let board = [];
let pot = 0;
let stage = "IDLE"; // PREFLOP/FLOP/TURN/RIVER/SHOWDOWN/IDLE
let dealer = 0;
let sb = 1, bb = 2;
let current = 0;
let toCall = 0;
let raisesThisRound = 0;
let awaitingHuman = false;
let tournamentStarted = false;
let handInProgress = false;
let botTimer = null;

/* =========================
   UI refs
========================= */
const elTable = document.getElementById("table");
const elBoard = document.getElementById("board");
const elStage = document.getElementById("stage");
const elPot = document.getElementById("pot");
const elToCall = document.getElementById("tocall");
const elDealer = document.getElementById("dealer");
const elMsg = document.getElementById("msg");
const elLog = document.getElementById("log");

const elNick = document.getElementById("nick");
const elEur = document.getElementById("eur");

const btnShop = document.getElementById("btnShop");
const btnReset = document.getElementById("btnReset");

const btnStart = document.getElementById("btnStart");
const btnNextHand = document.getElementById("btnNextHand");
const btnFold = document.getElementById("btnFold");
const btnCall = document.getElementById("btnCall");
const btnRaise = document.getElementById("btnRaise");

const raiseSlider = document.getElementById("raiseSlider");
const raiseToLabel = document.getElementById("raiseToLabel");
const raiseMinEl = document.getElementById("raiseMin");
const raiseMaxEl = document.getElementById("raiseMax");

const nickModal = document.getElementById("nickModal");
const nickInput = document.getElementById("nickInput");
const nickOk = document.getElementById("nickOk");

const shopModal = document.getElementById("shopModal");
const shopClose = document.getElementById("shopClose");

/* =========================
   Persistence (per nick)
========================= */
function keyForNick(n){ return `poker_save_${n.toLowerCase()}`; }

function saveState(){
  if(!saveKey) return;
  const state = {
    version: 1,
    nick,
    players,
    dealer, sb, bb, current,
    deck, board,
    pot, stage,
    toCall, raisesThisRound,
    awaitingHuman, tournamentStarted, handInProgress,
    log: elLog.textContent.slice(0, 6000)
  };
  localStorage.setItem(saveKey, JSON.stringify(state));
}

function loadState(n){
  const k = keyForNick(n);
  const raw = localStorage.getItem(k);
  if(!raw) return null;
  try { return JSON.parse(raw); } catch { return null; }
}

function resetSave(){
  if(!saveKey) return;
  localStorage.removeItem(saveKey);
  elLog.textContent = "";
  elMsg.textContent = "–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ. –ù–∞–∂–º–∏ Start / Resume.";
  tournamentStarted = false;
  handInProgress = false;
  stage = "IDLE";
  render();
}

/* =========================
   Helpers / UI
========================= */
function logLine(s){
  elLog.textContent = (s + "\n" + elLog.textContent).slice(0, 6000);
}

function newDeck(){
  const d = [];
  for(const s of SUITS) for(const r of RANKS) d.push({r,s});
  for(let i=d.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}
function activePlayers(){ return players.filter(p => !p.out); }
function inHandPlayers(){ return players.filter(p => !p.out && !p.folded); }

function nextActiveIndex(from){
  const n = players.length;
  for(let k=1;k<=n;k++){
    const i = (from + k) % n;
    if(!players[i].out && !players[i].folded) return i;
  }
  return from;
}
function nextNotOutIndex(from){
  const n = players.length;
  for(let k=1;k<=n;k++){
    const i = (from + k) % n;
    if(!players[i].out) return i;
  }
  return from;
}
function onlyOneLeftInHand(){ return inHandPlayers().length === 1; }

function chipFly(text){
  const el = document.createElement("div");
  el.className = "chip-fly";
  el.textContent = text;
  elTable.appendChild(el);
  setTimeout(()=>el.remove(), 750);
}

/* =========================
   Hand evaluator (real-ish)
========================= */
function straightHigh(uniqueRanksDesc){
  const set = new Set(uniqueRanksDesc);
  if(set.has(14) && set.has(5) && set.has(4) && set.has(3) && set.has(2)) return 5;
  for(let hi=14;hi>=5;hi--){
    let ok=true;
    for(let d=0;d<5;d++){
      if(!set.has(hi-d)){ ok=false; break; }
    }
    if(ok) return hi;
  }
  return 0;
}
function evaluate7(cards){
  const ranks = cards.map(c=>RVAL[c.r]).sort((a,b)=>b-a);
  const suitMap = new Map();
  const countMap = new Map();
  for(const c of cards){
    suitMap.set(c.s, (suitMap.get(c.s)||0)+1);
    const v = RVAL[c.r];
    countMap.set(v, (countMap.get(v)||0)+1);
  }
  const unique = [...new Set(ranks)].sort((a,b)=>b-a);

  let flushSuit = null;
  for(const [s,c] of suitMap.entries()){
    if(c>=5){ flushSuit = s; break; }
  }
  let flushRanks = null;
  if(flushSuit){
    flushRanks = cards.filter(c=>c.s===flushSuit).map(c=>RVAL[c.r]).sort((a,b)=>b-a);
  }

  // straight flush
  if(flushRanks){
    const uniqFlush = [...new Set(flushRanks)].sort((a,b)=>b-a);
    const sf = straightHigh(uniqFlush);
    if(sf) return { cat: 8, tiebreak: [sf] };
  }

  const groups = [...countMap.entries()]
    .map(([r,c])=>({r,c}))
    .sort((a,b)=> (b.c-a.c) || (b.r-a.r));
  const fours = groups.filter(g=>g.c===4).map(g=>g.r);
  const threes = groups.filter(g=>g.c===3).map(g=>g.r);
  const pairs  = groups.filter(g=>g.c===2).map(g=>g.r);

  if(fours.length){
    const quad = Math.max(...fours);
    const kicker = unique.find(r=>r!==quad);
    return { cat: 7, tiebreak: [quad, kicker] };
  }

  if(threes.length){
    const trip = Math.max(...threes);
    const remainingTrips = threes.filter(r=>r!==trip);
    const bestPair = pairs.length ? Math.max(...pairs) : (remainingTrips.length ? Math.max(...remainingTrips) : 0);
    if(bestPair) return { cat: 6, tiebreak: [trip, bestPair] };
  }

  if(flushRanks){
    return { cat: 5, tiebreak: flushRanks.slice(0,5) };
  }

  const st = straightHigh(unique);
  if(st) return { cat: 4, tiebreak: [st] };

  if(threes.length){
    const trip = Math.max(...threes);
    const kickers = unique.filter(r=>r!==trip).slice(0,2);
    return { cat: 3, tiebreak: [trip, ...kickers] };
  }

  if(pairs.length >= 2){
    const sortedPairs = [...pairs].sort((a,b)=>b-a);
    const p1 = sortedPairs[0], p2 = sortedPairs[1];
    const kicker = unique.find(r=>r!==p1 && r!==p2);
    return { cat: 2, tiebreak: [p1, p2, kicker] };
  }

  if(pairs.length === 1){
    const p = pairs[0];
    const kickers = unique.filter(r=>r!==p).slice(0,3);
    return { cat: 1, tiebreak: [p, ...kickers] };
  }

  return { cat: 0, tiebreak: unique.slice(0,5) };
}
function compareEval(a,b){
  if(a.cat !== b.cat) return a.cat - b.cat;
  for(let i=0;i<Math.max(a.tiebreak.length,b.tiebreak.length);i++){
    const x=a.tiebreak[i]||0, y=b.tiebreak[i]||0;
    if(x!==y) return x-y;
  }
  return 0;
}
function catName(cat){
  return ["High","Pair","Two Pair","Trips","Straight","Flush","Full House","Quads","Straight Flush"][cat] || "Unknown";
}

/* =========================
   Betting helpers
========================= */
function resetRoundBets(){
  for(const p of players) p.bet = 0;
  toCall = 0;
  raisesThisRound = 0;
}
function postBlind(i, amount){
  const p = players[i];
  const pay = Math.min(amount, p.chips);
  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  if(pay>0) chipFly(`-${pay}`);
}
function bettingRoundComplete(){
  const ps = inHandPlayers();
  for(const p of ps){
    if(p.chips === 0) continue;
    if(p.bet !== toCall) return false;
  }
  return true;
}
function minRaiseTo(){
  // –ø—Ä–æ—Å—Ç–æ–µ –ø—Ä–∞–≤–∏–ª–æ: –º–∏–Ω–∏–º—É–º "toCall + BB" (–±—ã—Å—Ç—Ä–æ –∏ –ø–æ–Ω—è—Ç–Ω–æ)
  return toCall + BIG_BLIND;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

/* =========================
   Elimination & winner
========================= */
function cleanupEliminations(){
  for(const p of players){
    if(!p.out && p.chips <= 0){
      p.out = true;
      p.chips = 0;
      logLine(`${p.name} is OUT!`);
    }
  }
}
function checkTournamentWinner(){
  const alive = players.filter(p => !p.out);
  if(alive.length === 1){
    elMsg.textContent = `üèÜ CHAMPION: ${alive[0].name}!`;
    logLine(`üèÜ TOURNAMENT WINNER: ${alive[0].name}`);
    handInProgress = false;
    stage = "IDLE";
    awaitingHuman = false;
    saveState();
  }
}
function awardPotTo(idx, reason){
  players[idx].chips += pot;
  chipFly(`+${pot}`);
  logLine(`${players[idx].name} wins ${pot} ${reason||""}`.trim());
  pot = 0;
  handInProgress = false;
  stage = "IDLE";
  awaitingHuman = false;
  cleanupEliminations();
  checkTournamentWinner();
  render();
  saveState();
}

/* =========================
   Tournament init/resume
========================= */
function createFreshTournament(){
  players = [];
  players.push({name:nick, isBot:false, chips:START_CHIPS, bet:0, folded:false, out:false, hand:[]});
  for(let i=1;i<=BOT_COUNT;i++){
    players.push({name:`BOT${i}`, isBot:true, chips:START_CHIPS, bet:0, folded:false, out:false, hand:[]});
  }
  dealer = 0; sb = 1; bb = 2;
  current = 0;
  deck = [];
  board = [];
  pot = 0;
  stage = "IDLE";
  toCall = 0;
  raisesThisRound = 0;
  awaitingHuman = false;
  tournamentStarted = true;
  handInProgress = false;
  elLog.textContent = "";
  logLine("Tournament created.");
  elMsg.textContent = "–ù–∞–∂–º–∏ Next Hand.";
  render();
  saveState();
}

function resumeOrStart(){
  if(!nick) return;
  const st = loadState(nick);
  if(st && st.players && st.players.length){
    // restore
    players = st.players;
    // ensure YOU name updated to current nick
    if(players[0] && !players[0].isBot) players[0].name = nick;

    dealer = st.dealer ?? 0;
    sb = st.sb ?? 1;
    bb = st.bb ?? 2;
    current = st.current ?? 0;

    deck = st.deck ?? [];
    board = st.board ?? [];
    pot = st.pot ?? 0;
    stage = st.stage ?? "IDLE";
    toCall = st.toCall ?? 0;
    raisesThisRound = st.raisesThisRound ?? 0;
    awaitingHuman = false;
    tournamentStarted = st.tournamentStarted ?? true;
    handInProgress = st.handInProgress ?? false;

    elLog.textContent = st.log ?? "";
    cleanupEliminations();
    checkTournamentWinner();

    logLine("Resumed from save.");
    render();
    tick(); // continue if bots turn
  } else {
    createFreshTournament();
  }
}

/* =========================
   Hand flow
========================= */
function startHand(){
  if(!tournamentStarted) return;
  cleanupEliminations();
  checkTournamentWinner();
  if(players.filter(p=>!p.out).length < 2) { render(); return; }

  handInProgress = true;
  deck = newDeck();
  board = [];
  pot = 0;

  for(const p of players){
    p.folded = false;
    p.bet = 0;
    p.hand = [];
  }

  dealer = nextNotOutIndex(dealer);
  sb = nextNotOutIndex(dealer);
  bb = nextNotOutIndex(sb);

  // deal (with animation class)
  for(let r=0;r<2;r++){
    for(const p of players){
      if(!p.out) p.hand.push(deck.pop());
    }
  }

  resetRoundBets();
  postBlind(sb, SMALL_BLIND);
  postBlind(bb, BIG_BLIND);
  toCall = Math.max(players[sb].bet, players[bb].bet);

  stage = "PREFLOP";
  current = nextActiveIndex(bb);
  awaitingHuman = false;

  logLine(`--- New hand --- Dealer: ${players[dealer].name} | SB:${players[sb].name} BB:${players[bb].name}`);
  elMsg.textContent = "–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å.";
  render();
  saveState();
  tick();
}

function advanceStage(){
  for(const p of players) p.bet = 0;
  toCall = 0;
  raisesThisRound = 0;

  if(stage==="PREFLOP"){
    board.push(deck.pop(), deck.pop(), deck.pop());
    stage="FLOP";
  } else if(stage==="FLOP"){
    board.push(deck.pop());
    stage="TURN";
  } else if(stage==="TURN"){
    board.push(deck.pop());
    stage="RIVER";
  } else if(stage==="RIVER"){
    stage="SHOWDOWN";
  }

  current = nextActiveIndex(dealer);
  awaitingHuman = false;

  if(stage==="SHOWDOWN"){
    doShowdown();
    return;
  }

  logLine(`Stage: ${stage}`);
  render();
  saveState();
}

function doShowdown(){
  const contenders = inHandPlayers();
  if(contenders.length === 1){
    awardPotTo(players.indexOf(contenders[0]), "(everyone folded)");
    return;
  }
  const evals = contenders.map(p=>{
    const seven = [...p.hand, ...board];
    const e = evaluate7(seven);
    return {p,e};
  });
  evals.sort((a,b)=>compareEval(a.e,b.e));
  const best = evals[evals.length-1].e;
  const winners = evals.filter(x=>compareEval(x.e,best)===0).map(x=>x.p);

  logLine(`Showdown: best=${catName(best.cat)} winners=${winners.map(w=>w.name).join(", ")}`);

  const share = Math.floor(pot / winners.length);
  let rem = pot - share*winners.length;
  for(const w of winners){
    w.chips += share;
    if(rem>0){ w.chips += 1; rem--; }
  }
  chipFly(`+${pot}`);
  pot = 0;

  handInProgress = false;
  stage = "IDLE";
  awaitingHuman = false;
  cleanupEliminations();
  checkTournamentWinner();
  render();
  saveState();
}

function playerFold(i){
  players[i].folded = true;
  logLine(`${players[i].name} folds`);
  render();
  saveState();

  if(onlyOneLeftInHand()){
    awardPotTo(players.indexOf(inHandPlayers()[0]), "(everyone folded)");
    return;
  }
  current = nextActiveIndex(i);
  tick();
}

function playerCall(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  const pay = Math.min(need, p.chips);
  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  if(pay>0) chipFly(`-${pay}`);
  logLine(`${p.name} ${need===0 ? "checks" : "calls"} ${pay}`);
  render();
  saveState();

  current = nextActiveIndex(i);
  if(bettingRoundComplete()){
    advanceStage();
    return;
  }
  tick();
}

function playerRaiseTo(i, raiseTo){
  if(raisesThisRound >= MAX_RAISES_PER_ROUND){
    playerCall(i);
    return;
  }
  const p = players[i];
  raiseTo = Math.max(raiseTo, minRaiseTo());
  raiseTo = Math.min(raiseTo, p.bet + p.chips); // can't exceed all-in

  const add = Math.max(0, raiseTo - p.bet);
  const pay = Math.min(add, p.chips);
  if(pay <= 0){
    playerCall(i);
    return;
  }

  p.chips -= pay;
  p.bet += pay;
  pot += pay;
  toCall = Math.max(toCall, p.bet);
  raisesThisRound++;
  chipFly(`-${pay}`);
  logLine(`${p.name} raises to ${p.bet}`);
  render();
  saveState();

  current = nextActiveIndex(i);
  tick();
}

/* =========================
   Smarter Bot AI
   - uses real category postflop
   - uses pot odds & pressure
========================= */
function botDecision(i){
  const p = players[i];
  const need = Math.max(0, toCall - p.bet);
  const stack = Math.max(1, p.chips);
  const potOdds = need / Math.max(1, pot + need); // rough
  const pressure = need / (stack + 1);

  // preflop score
  if(stage === "PREFLOP"){
    const a = RVAL[p.hand[0].r], b = RVAL[p.hand[1].r];
    const pair = p.hand[0].r === p.hand[1].r;
    const suited = p.hand[0].s === p.hand[1].s;
    const gap = Math.abs(a-b);
    const high = Math.max(a,b);

    let score = 0.0;
    score += pair ? 0.55 : 0.0;
    score += (high/14)*0.30;
    score += suited ? 0.08 : 0.0;
    score += (gap<=2) ? 0.06 : 0.0;
    score += (high>=12) ? 0.06 : 0.0;
    score += (Math.random()-0.5)*0.06;

    if(need===0){
      if(score>0.72 && p.chips > BIG_BLIND*2 && Math.random()<0.40) return {type:"RAISE"};
      return {type:"CALL"};
    }

    // fold if —Å–ª–∞–±–æ–µ –∏ –¥–æ—Ä–æ–≥–æ
    if(score < 0.33 && (pressure>0.12 || potOdds>0.28) && Math.random()<0.78) return {type:"FOLD"};

    // raise if —Å–∏–ª—å–Ω–æ–µ
    if(score > 0.74 && p.chips > need + BIG_BLIND && Math.random()<0.55) return {type:"RAISE"};

    return {type:"CALL"};
  }

  // postflop: real eval category + board texture approx
  const seven = [...p.hand, ...board];
  const e = evaluate7(seven);
  let strength = (e.cat / 8);                 // 0..1
  strength += (Math.random()-0.5)*0.08;       // randomness

  // If very strong -> raise sometimes
  if(need===0){
    if(strength > 0.62 && p.chips > BIG_BLIND*2 && raisesThisRound < MAX_RAISES_PER_ROUND && Math.random()<0.35)
      return {type:"RAISE"};
    return {type:"CALL"};
  }

  // if weak + expensive -> fold often
  if(strength < 0.25 && (pressure>0.14 || potOdds>0.30) && Math.random()<0.80) return {type:"FOLD"};

  // if decent and pot odds good -> call
  if(strength > 0.30 && potOdds < 0.34) {
    if(strength > 0.70 && p.chips > need + BIG_BLIND && raisesThisRound < MAX_RAISES_PER_ROUND && Math.random()<0.45)
      return {type:"RAISE"};
    return {type:"CALL"};
  }

  // medium: mix
  if(strength > 0.45 && raisesThisRound < MAX_RAISES_PER_ROUND && Math.random()<0.22) return {type:"RAISE"};
  if(Math.random()<0.15) return {type:"FOLD"};
  return {type:"CALL"};
}

function botAct(){
  if(!handInProgress) return;
  if(players[current].out || players[current].folded){
    current = nextActiveIndex(current);
  }
  if(onlyOneLeftInHand()){
    awardPotTo(players.indexOf(inHandPlayers()[0]), "(everyone folded)");
    return;
  }

  const d = botDecision(current);
  if(d.type==="FOLD") playerFold(current);
  else if(d.type==="RAISE"){
    const p = players[current];
    const min = minRaiseTo();
    // pick raise size based on stack
    const maxTo = p.bet + p.chips;
    let target = min + Math.floor(Math.random()*3)*BIG_BLIND;
    // stronger hand tends to raise more
    if(stage!=="PREFLOP"){
      const e = evaluate7([...p.hand,...board]);
      if(e.cat >= 4) target += BIG_BLIND*3;
      if(e.cat >= 6) target += BIG_BLIND*5;
    }
    target = clamp(target, min, maxTo);
    playerRaiseTo(current, target);
  } else {
    playerCall(current);
  }
}

/* =========================
   Tick (turn manager)
========================= */
function tick(){
  clearTimeout(botTimer);

  if(!handInProgress){
    awaitingHuman = false;
    updateButtons();
    updateRaiseUI();
    return;
  }

  if(stage==="IDLE" || stage==="SHOWDOWN"){
    awaitingHuman = false;
    updateButtons();
    updateRaiseUI();
    return;
  }

  if(players[current].out || players[current].folded){
    current = nextActiveIndex(current);
  }

  if(!players[current].isBot){
    awaitingHuman = true;
    elMsg.textContent = "–¢–≤–æ–π —Ö–æ–¥: Fold / Call-Check / Raise";
    updateRaiseUI();
    updateButtons();
    return;
  }

  awaitingHuman = false;
  elMsg.textContent = "–ë–æ—Ç –¥—É–º–∞–µ—Ç‚Ä¶";
  updateRaiseUI();
  updateButtons();

  botTimer = setTimeout(()=>botAct(), BOT_THINK_MS);
}

/* =========================
   Rendering
========================= */
function makeCardEl(text, hidden, animate){
  const el = document.createElement("div");
  el.className = "card" + (hidden ? " hidden" : "") + (animate ? " deal" : "");
  if(hidden){
    el.textContent = "üÇ†";
    return el;
  }
  if(!text){
    el.style.opacity = "0.35";
    el.textContent = "‚Äî";
    return el;
  }
  const r = text.slice(0,1);
  const s = text.slice(1);
  const small = document.createElement("small");
  small.textContent = r;
  const suit = document.createElement("div");
  suit.className = "suit";
  suit.textContent = s;
  el.appendChild(small);
  el.appendChild(suit);
  return el;
}

function render(){
  // remove seats
  [...elTable.querySelectorAll(".seat")].forEach(n=>n.remove());

  // board
  elBoard.innerHTML = "";
  for(let i=0;i<5;i++){
    const c = board[i];
    elBoard.appendChild(makeCardEl(c ? (c.r+c.s) : "", !c, !!c));
  }

  elStage.textContent = stage;
  elPot.textContent = pot;
  elToCall.textContent = toCall;
  elDealer.textContent = tournamentStarted ? (players[dealer]?.name ?? "-") : "-";

  const seatPos = ["pos-0","pos-1","pos-2","pos-3","pos-4","pos-5"];

  for(let i=0;i<players.length;i++){
    const p = players[i];
    const seat = document.createElement("div");
    seat.className = `seat ${seatPos[i]||"pos-5"}`;

    const top = document.createElement("div");
    top.className = "top";

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = p.name;

    const tag = document.createElement("div");
    tag.className = "tag";
    if(p.out){ tag.classList.add("out"); tag.textContent = "OUT"; }
    else if(handInProgress && i===current && !p.folded){ tag.classList.add("turn"); tag.textContent = "TURN"; }
    else tag.textContent = p.isBot ? "BOT" : "YOU";

    top.appendChild(name);
    top.appendChild(tag);

    const meta = document.createElement("div");
    meta.className = "meta";
    meta.innerHTML =
      `<span class="chips">chips: <b>${p.chips}</b></span>
       <span>${p.folded ? "<span style='color:var(--danger)'>folded</span>" : ""}</span>`;

    const cards = document.createElement("div");
    cards.className = "cards";

    const hidden = p.isBot && handInProgress && stage!=="SHOWDOWN";
    const c1 = p.hand?.[0], c2 = p.hand?.[1];
    const show = !p.isBot || stage==="SHOWDOWN" || !handInProgress;

    cards.appendChild(makeCardEl(c1 ? (c1.r+c1.s) : "", hidden || !show, !!c1));
    cards.appendChild(makeCardEl(c2 ? (c2.r+c2.s) : "", hidden || !show, !!c2));

    const bet = document.createElement("div");
    bet.className = "bet";
    bet.textContent = p.out ? "" : (p.bet>0 ? `Bet: ${p.bet}` : "");

    seat.appendChild(top);
    seat.appendChild(meta);
    seat.appendChild(cards);
    seat.appendChild(bet);

    elTable.appendChild(seat);
  }

  updateRaiseUI();
  updateButtons();
}

function updateButtons(){
  btnStart.disabled = !nick ? true : false;
  btnNextHand.disabled = !tournamentStarted || handInProgress || players.filter(p=>!p.out).length<2;

  const yourTurn = tournamentStarted && handInProgress && awaitingHuman && current===0 && !players[0].folded && !players[0].out;
  btnFold.disabled = !yourTurn;
  btnCall.disabled = !yourTurn;
  btnRaise.disabled = !yourTurn || raisesThisRound >= MAX_RAISES_PER_ROUND;
}

function updateRaiseUI(){
  const you = players[0];
  if(!you || !handInProgress){
    raiseSlider.min = 0; raiseSlider.max = 0; raiseSlider.value = 0;
    raiseToLabel.textContent = "0";
    raiseMinEl.textContent = "0";
    raiseMaxEl.textContent = "0";
    return;
  }

  const minTo = minRaiseTo();
  const maxTo = you.bet + you.chips; // all-in
  const safeMin = clamp(minTo, 0, maxTo);

  raiseSlider.min = safeMin;
  raiseSlider.max = maxTo;
  if(Number(raiseSlider.value) < safeMin) raiseSlider.value = safeMin;
  if(Number(raiseSlider.value) > maxTo) raiseSlider.value = maxTo;

  raiseMinEl.textContent = String(safeMin);
  raiseMaxEl.textContent = String(maxTo);
  raiseToLabel.textContent = String(raiseSlider.value);
}

/* =========================
   UI: modals
========================= */
function openNickModal(){
  nickModal.style.display = "flex";
  nickInput.value = "";
  nickInput.focus();
}
function closeNickModal(){
  nickModal.style.display = "none";
}
function openShop(){ shopModal.style.display = "flex"; }
function closeShop(){ shopModal.style.display = "none"; }

/* =========================
   Buttons
========================= */
btnStart.addEventListener("click", () => {
  if(!nick) { openNickModal(); return; }
  resumeOrStart();
});

btnNextHand.addEventListener("click", () => {
  startHand();
});

btnFold.addEventListener("click", () => {
  if(awaitingHuman && current===0){ awaitingHuman=false; playerFold(0); }
});

btnCall.addEventListener("click", () => {
  if(awaitingHuman && current===0){ awaitingHuman=false; playerCall(0); }
});

btnRaise.addEventListener("click", () => {
  if(awaitingHuman && current===0){
    awaitingHuman=false;
    playerRaiseTo(0, Number(raiseSlider.value));
  }
});

raiseSlider.addEventListener("input", () => {
  raiseToLabel.textContent = String(raiseSlider.value);
});

btnShop.addEventListener("click", () => {
  if(!nick) { openNickModal(); return; }
  openShop();
});

shopClose.addEventListener("click", closeShop);

shopModal.addEventListener("click", (e) => {
  if(e.target === shopModal) closeShop();
});

shopModal.querySelectorAll("[data-buy]").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const amt = Number(btn.getAttribute("data-buy"));
    if(players[0] && !players[0].out){
      players[0].chips += amt;
      logLine(`Shop: +${amt} chips to ${players[0].name}`);
      chipFly(`+${amt}`);
      render();
      saveState();
    }
  });
});

btnReset.addEventListener("click", () => {
  if(confirm("–¢–æ—á–Ω–æ —É–¥–∞–ª–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ –Ω–∏–∫–∞?")) resetSave();
});

nickOk.addEventListener("click", () => {
  const n = nickInput.value.trim();
  if(!n){ nickInput.focus(); return; }
  nick = n;
  saveKey = keyForNick(nick);
  elNick.textContent = nick;
  closeNickModal();
  resumeOrStart();
});

nickInput.addEventListener("keydown", (e)=>{
  if(e.key==="Enter") nickOk.click();
});

nickModal.addEventListener("click", (e)=>{
  if(e.target === nickModal) { /* –Ω–µ–ª—å–∑—è –∑–∞–∫—Ä—ã—Ç—å –±–µ–∑ –Ω–∏–∫–∞ */ }
});

/* =========================
   Boot
========================= */
function boot(){
  elEur.textContent = "‚àû";

  // If last nick saved
  const last = localStorage.getItem("poker_last_nick");
  if(last){
    nick = last;
    saveKey = keyForNick(nick);
    elNick.textContent = nick;
    elMsg.textContent = `–ù–∞–π–¥–µ–Ω –Ω–∏–∫: ${nick}. –ù–∞–∂–º–∏ Start / Resume.`;
  } else {
    elMsg.textContent = "–ù–∞–∂–º–∏ Start / Resume (–ø–æ–ø—Ä–æ—Å–∏—Ç –Ω–∏–∫).";
  }

  btnStart.addEventListener("click", ()=> {
    if(nick) localStorage.setItem("poker_last_nick", nick);
  });

  render();
  updateButtons();
}
boot();

/* When user sets nick, remember it */
const origNickOk = nickOk.onclick;
nickOk.addEventListener("click", ()=> {
  if(nick) localStorage.setItem("poker_last_nick", nick);
});
</script>
</body>
</html>
